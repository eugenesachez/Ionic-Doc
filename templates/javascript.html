<ion-view view-title="Javascript">
  <ion-content class="container">
<h1>Angula JS Extensions</h1>

    <p>Ionic is both a CSS framework and a Javascript UI library. Many components need Javascript in order to produce magic, though often components can easily be used without coding through framework extensions such as our AngularIonic extensions.

	<p>Ionic follows the View Controller pattern popularized in such frameworks as Cocoa Touch. In the View Controller pattern, we treat different sections of the interface as child Views or even child View Controllers that contain other views. View Controllers then “power” the Views inside of them to provide interaction and UI functionality. A great example is the Tab Bar View Controller which processes taps on a Tab Bar to switch between a set of viewable panes.</p>

	<p>Explore our API docs for detailed information on the View Controllers and Javascript utilities available in Ionic.</p>
	
	<h2>Action Sheet</h2>

<h3 class="title">$ionicActionSheet</h3>
	<p>The Action Sheet is a slide-up pane that lets the user choose from a set of options. Dangerous options are highlighted in red and made obvious.</p>

	<p>There are easy ways to cancel out of the action sheet, such as tapping the backdrop or even hitting escape on the keyboard for desktop testing.</p>
	<h4>Usage</h4>
	<p>To trigger an Action Sheet in your code, use the $ionicActionSheet service in your angular controllers:</p>
	<h4>Usage</h4>
	
	<pre>
angular.module(&apos;mySuperApp&apos;, [&apos;ionic&apos;])
.controller(function($scope, $ionicActionSheet, $timeout) {

 // Triggered on a button click, or some other target
 $scope.show = function() {

   // Show the action sheet
   var hideSheet = $ionicActionSheet.show({
     buttons: [
       { text: &apos;&lt;b&gt;Share&lt;/b&gt; This&apos; },
       { text: &apos;Move&apos; }
     ],
     destructiveText: &apos;Delete&apos;,
     titleText: &apos;Modify your album&apos;,
     cancelText: &apos;Cancel&apos;,
     cancel: function() {
          // add cancel code..
        },
     buttonClicked: function(index) {
       return true;
     }
   });

   // For example&apos;s sake, hide the sheet after two seconds
   $timeout(function() {
     hideSheet();
   }, 2000);

 };
});	</pre>

<h4>Methods</h4>
<p><code>show(options)</code></p>
<p>Load and return a new action sheet.</p>

<p>A new isolated scope will be created for the action sheet and the new element will be appended into the body.</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>options</td>
			<td><code>objects</code></td>
			<td><p>
			The options for this actionSheet. Properties:</p>
			<ul>
				<li><code>[Object]</code> <code>buttons</code> Which buttons to show. Each button is an object with a <code>text</code> field.</li>
				<li><code>{string}</code> <code>titleText</code> The title to show on the action sheet.</li>
				<li><code>{string=}</code> <code>cancelText</code> the text for a 'cancel' button on the action sheet.</li>
			</ul>
			</td>
		</tr>
		<tbody>
		</table>
		




<h3 class="title">$ioicBackdrop</h3>
	<p>Shows and hides a backdrop over the UI. Appears behind popups, loading, and other overlays.

	<p>Often, multiple UI components require a backdrop, but only one backdrop is ever needed in the DOM at a time.</p>

	<p>Therefore, each component that requires the backdrop to be shown calls <code>$ionicBackdrop.retain()</code> when it wants the backdrop, then <code>$ionicBackdrop.release()</code> when it is done with the backdrop.</p>

	<p>For each time <code>retain</code> is called, the backdrop will be shown until <code>release</code> is called.</p>

	<p>For example, if <code>retain</code> is called three times, the backdrop will be shown until <code>release</code> is called three times.</p>

	<p><strong>Notes:</strong> - The backdrop service will broadcast ‘backdrop.shown’ and ‘backdrop.hidden’ events from the root scope, this is useful for alerting native components not in html.</p>
	<h4>Usage</h4>
	<pre>
function MyController($scope, $ionicBackdrop, $timeout, $rootScope) {
  //Show a backdrop for one second
  $scope.action = function() {
    $ionicBackdrop.retain();
    $timeout(function() {
      $ionicBackdrop.release();
    }, 1000);
  };

  // Execute action on backdrop disappearing
  $scope.$on(&apos;backdrop.hidden&apos;, function() {
    // Execute action
  });

  // Execute action on backdrop appearing
  $scope.$on(&apos;backdrop.shown&apos;, function() {
    // Execute action
  });

}
	</pre>
	<h4>Methods</h4>
	<p><code>retain()</code>
	Retains the backdrop.</br>

	<code>release()</code>
	Releases the backdrop.</p>

<h3 class="title">ion-content</h3>
	<p>Delegate: <code>$ionicScrollDelegate</code></p>
	<p>The ionContent directive provides an easy to use content area that can be configured to use Ionic’s custom Scroll View, or the built in overflow scrolling of the browser.

	<p>While we recommend using the custom Scroll features in Ionic in most cases, sometimes (for performance reasons) only the browser’s native overflow scrolling will suffice, and so we’ve made it easy to toggle between the Ionic scroll implementation and overflow scrolling.</p>

	<p>You can implement pull-to-refresh with the <code>ionRefresher</code> directive, and infinite scrolling with the <code>ionInfiniteScroll</code> directive.</p>

	<p>If there is any dynamic content inside the ion-content, be sure to call <code>.resize()</code> with <code>$ionicScrollDelegate</code> after the content has been added.</p>

	<p>Be aware that this directive gets its own child scope. If you do not understand why this is important, you can read https://docs.angularjs.org/guide/scope.</p>

<pre>
&lt;ion-content
[delegate-handle=&quot;&quot;]
[direction=&quot;&quot;]
[locking=&quot;&quot;]
[padding=&quot;&quot;]
[scroll=&quot;&quot;]
[overflow-scroll=&quot;&quot;]
[scrollbar-x=&quot;&quot;]
[scrollbar-y=&quot;&quot;]
[start-x=&quot;&quot;]
[start-y=&quot;&quot;]
[on-scroll=&quot;&quot;]
[on-scroll-complete=&quot;&quot;]
[has-bouncing=&quot;&quot;]
[scroll-event-interval=&quot;&quot;]&gt;
...
&lt;/ion-content&gt;
</pre>
<h4>API</h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Attr</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>delegate-handle <div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>"The handle used to identify this scrollView with <code>$ionicScrollDelegate</code>"</p></td>
		</tr>
		<tr>
			<td>direction <div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>Which way to scroll. 'x' or 'y' or 'xy'. Default 'y'.</p></td>
		</tr>
		<tr>
			<td>locking <div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>Whether to lock scrolling in one direction at a time. Useful to set to false when zoomed in or scrolling in two directions. Default true.</p></td>
		</tr>
		<tr>
			<td>padding <div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>Whether to add padding to the content. Defaults to true on iOS, false on Android.</p></td>
		</tr>
		<tr>
			<td>scroll <div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>Whether to allow scrolling of content. Defaults to true.</p></td>
		</tr>
		<tr>
			<td>overflow-scroll <div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>Whether to use overflow-scrolling instead of Ionic scroll. See <code>$ionicConfigProvider</code> to set this as the global default.</p></td>
		</tr>
		<tr>
			<td>scrollbar-y <div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>Whether to show the vertical scrollbar. Default true.</p></td>
		</tr>
		<tr>
			<td>start-x <div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>Initial horizontal scroll position. Default 0.</p></td>
		</tr>
		<tr>
			<td>start-y <div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>Initial vertical scroll position. Default 0.</p></td>
		</tr>
		<tr>
			<td>on-scroll <div><em>(optional)</em></div></td>
			<td><code>expression</code></td>
			<td><p>Expression to evaluate when the content is scrolled.</p></td>
		</tr>
		<tr>
			<td>on-scroll-complete <div><em>(optional)</em></div></td>
			<td><code>expression</code></td>
			<td><p>Expression to evaluate when a scroll action completes. Has access to 'scrollLeft' and 'scrollTop' locals.</p></td>
		</tr>
		<tr>
			<td>has-bouncing <div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>Whether to allow scrolling to bounce past the edges of the content. Defaults to true on iOS, false on Android.</p></td>
		</tr>
		<tr>
			<td>scroll-event-interval <div><em>(optional)</em></div></td>
			<td><code>number</code></td>
			<td><p>Number of milliseconds between each firing of the 'on-scroll' expression. Default 10.</p></td>
		</tr>
	</tbody>
</table>
<!-- ion-refresher -->
<h3>Ion-refresher</h3>
<p>Child of <code>ionContent</code> or <code>ionScroll</code></p>

<p>Allows you to add pull-to-refresh to a scrollView.</p>

<p>Place it as the first child of your <code>ionContent</code> or <code>ionScroll</code> element.</p>

<p>When refreshing is complete, $broadcast the ‘scroll.refreshComplete’ event from your controller.</p>
<h4>Usage</h4>
<pre>
&lt;ion-content ng-controller=&quot;MyController&quot;&gt;
&lt;ion-refresher
  pulling-text=&quot;Pull to refresh...&quot;
  on-refresh=&quot;doRefresh()&quot;&gt;
 &lt;/ion-refresher&gt;
 &lt;ion-list&gt;
  &lt;ion-item ng-repeat=&quot;item in items&quot;&gt;&lt;/ion-item&gt;
&lt;/ion-list&gt;
&lt;/ion-content&gt;
</pre>
<pre>
angular.module(&apos;testApp&apos;, [&apos;ionic&apos;])
.controller(&apos;MyController&apos;, function($scope, $http) {
 $scope.items = [1,2,3];
 $scope.doRefresh = function() {
  $http.get(&apos;/new-items&apos;)
   .success(function(newItems) {
     $scope.items = newItems;
    })
   .finally(function() {
     // Stop the ion-refresher from spinning
     $scope.$broadcast(&apos;scroll.refreshComplete&apos;);
   });
};
});</pre>
</pre>
<h4>API</h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Attr</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>on-refrresh <div><em>(optional)</em></div></td>
			<td><code>expression</code></td>
			<td><p>Called when the user pulls down enough and lets go of the refresher.</p></td>
		</tr>
		<tr>
			<td>on-pulling <div><em>(optional)</em></div></td>
			<td><code>expression</code></td>
			<td><p>Called when the user starts to pull down on the refresher.</p></td>
		</tr>
		<tr>
			<td>pulling-text <div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>The text to display while the user is pulling down..</p></td>
		</tr>
		<tr>
			<td>pulling-icon <div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>The icon to display while the user is pulling down. Default: 'ion-android-arrow-down'.</p></td>
		</tr>
		<tr>
			<td>spinner <div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>The <code>ionSpinner</code> icon to display after user lets go of the refresher. The SVG <code>ionSpinner</code> is now the default, replacing rotating font icons. Set to none to disable both the spinner and the icon.</p></td>
		</tr>
		<tr>
			<td>refreshing-icon <div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>The font icon to display after user lets go of the refresher. This is deprecated in favor of the SVG <code>ionSpinner</code>.</p></td>
		</tr>
		<tr>
			<td>disable-pulling-rotation <div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>Disables the rotation animation of the pulling icon when it reaches its activated threshold. To be used with a custom <code>pulling-icon</code></p></td>
		</tr>
		</tbody>
</table>
<!-- ion-pane -->
<h3>Ion-pane</h3>
<p>A simple container that fits content, with no side effects. Adds the ‘pane’ class to the element.</p>

<h4>Usage</h4>
<pre>&lt;ion-pane&gt;
...
&lt;/ion-pane&gt;
</pre>
<!-- ion checkbox -->
<h3>ion-checkbox</h3>
<p>The checkbox is no different than the HTML checkbox input, except it’s styled differently.</p>

<p>The checkbox behaves like any AngularJS checkbox.</p>
<h4>Usage</h4>
<pre>&lt;ion-checkbox ng-model=&quot;isChecked&quot;&gt;Checkbox Label&lt;/ion-checkbox&gt;</pre>
<!-- ion-radio -->
<h3>ion-radio</h3>
<p>The radio directive is no different than the HTML radio input, except it’s styled differently.</p>

<p>Radio behaves like AngularJS radio.</p>
<h4>Usage</h4>
<pre>&lt;ion-radio ng-model=&quot;choice&quot; ng-value=&quot;&apos;A&apos;&quot;&gt;Choose A&lt;/ion-radio&gt;
&lt;ion-radio ng-model=&quot;choice&quot; ng-value=&quot;&apos;B&apos;&quot;&gt;Choose B&lt;/ion-radio&gt;
&lt;ion-radio ng-model=&quot;choice&quot; ng-value=&quot;&apos;C&apos;&quot;&gt;Choose C&lt;/ion-radio&gt;</pre>
<!-- ion-toggle -->
<h3>ion-toggle</h3>
<p>A toggle is an animated switch which binds a given model to a boolean.</p>

<p>Allows dragging of the switch’s nub.</p>

<p>The toggle behaves like any AngularJS checkbox otherwise.</p>
<h4>Usage</h4>
<p>Below is an example of a toggle directive which is wired up to the airplaneMode model and has the toggle-calm CSS class assigned to the inner element.</p>
<pre>&lt;ion-toggle ng-model=&quot;airplaneMode&quot; toggle-class=&quot;toggle-calm&quot;&gt;Airplane Mode&lt;/ion-toggle&gt;</pre>

<!-- gestures and events -->
<!-- on-hold -->
<h2>Gestures and Events</h2>
<h3>on-hold</h3>
<p>Touch stays at the same location for 500ms. Similar to long touch events available for AngularJS and jQuery.</p>
<h4>Usage</h4>
<pre>&lt;button on-hold=&quot;onHold()&quot; class=&quot;button&quot;&gt;Test&lt;/button&gt;</pre>
<h3>on-tap</h3>
<p>Quick touch at a location. If the duration of the touch goes longer than 250ms it is no longer a tap gesture.</p>
<h4>Usage</h4>
<pre>&lt;button on-tap=&quot;onTap()&quot; class=&quot;button&quot;&gt;Test&lt;/button&gt;</pre>
<h3>on-swipe-up</h3>
<p>Called when a moving touch has a high velocity moving up.</p>
<h4>Usage</h4>
<pre>&lt;button on-swipe-up=&quot;onSwipeUp()&quot; class=&quot;button&quot;&gt;Test&lt;/button&gt;
</pre>
<h3>on-swipe-right</h3>
<p>Called when a moving touch has a high velocity moving to the right.</p>
<h4>Usage</h4>
<pre>&lt;button on-swipe-right=&quot;onSwipeRight()&quot; class=&quot;button&quot;&gt;Test&lt;/button&gt;</pre>
<h3>on-double-tap</h3>
<p>Double tap touch at a location.</p>
<h4>Usage</h4>
<pre>&lt;button on-double-tap=&quot;onDoubleTap()&quot; class=&quot;button&quot;&gt;Test&lt;/button&gt;</pre>
<h3>on-touch</h3>
<p>Called immediately when the user first begins a touch. This gesture does not wait for a touchend/mouseup.</p>
<h4>Usage</h4>
<pre>&lt;button on-touch=&quot;onTouch()&quot; class=&quot;button&quot;&gt;Test&lt;/button&gt;</pre>
<h3>on-release</h3>
<p>Called when the user ends a touch.</p>
<h4>Usage</h4>
<pre></pre>
<h3>on-drag</h3>
<p>Move with one touch around on the page. Blocking the scrolling when moving left and right is a good practice. When all the drag events are blocking you disable scrolling on that area.</p>
<h4>Usage</h4>
<pre>&lt;button on-drag=&quot;onDrag()&quot; class=&quot;button&quot;&gt;Test&lt;/button&gt;</pre>
<h3>on-drag-up</h3>
<p>Called when the element is dragged up.</p>
<h4>Usage</h4>
<pre>&lt;button on-drag-up=&quot;onDragUp()&quot; class=&quot;button&quot;&gt;Test&lt;/button&gt;</pre>
<h3>on-drag-right</h3>
<p>Called when the element is dragged to the right.</p>
<h4>Usage</h4>
<pre>&lt;button on-drag-right=&quot;onDragRight()&quot; class=&quot;button&quot;&gt;Test&lt;/button&gt;</pre>
<h3>on-drag-down</h3>
<p>Called when the element is dragged down.</p>
<h4>Usage</h4>
<pre>&lt;button on-drag-down=&quot;onDragDown()&quot; class=&quot;button&quot;&gt;Test&lt;/button&gt;</pre>

<h3>on-drug-left</h3>
<p>Called when the element is dragged to the left.</p>
<h4>Usage</h4>
<pre>&lt;button on-drag-left=&quot;onDragLeft()&quot; class=&quot;button&quot;&gt;Test&lt;/button&gt;</pre>
<h3>on-swipe</h3>
<p>Called when a moving touch has a high velocity in any direction.</p>
<h4>Usage</h4>
<pre>&lt;button on-swipe=&quot;onSwipe()&quot; class=&quot;button&quot;&gt;Test&lt;/button&gt;</pre>
<h3>on-swipe-down</h3>
<p>Called when a moving touch has a high velocity moving down.</p>
<h4>Usage</h4>
<pre>&lt;button on-swipe-down=&quot;onSwipeDown()&quot; class=&quot;button&quot;&gt;Test&lt;/button&gt;</pre>
<h3>on-swipe-left</h3>
<p>Called when a moving touch has a high velocity moving to the left.</p>
<h4>Usage</h4>
<pre>&lt;button on-swipe-left=&quot;onSwipeLeft()&quot; class=&quot;button&quot;&gt;Test&lt;/button&gt;</pre>
<h3>$ionicGesture</h3>
<p>An angular service exposing ionic <code>ionic.EventController</code>’s gestures.</p>
<h4>Methods</h4>
<p><code>on(eventType, callback, $element, options)</code></p>
<p>Add an event listener for a gesture on an element. See <code>ionic.EventController</code>.</p>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>eventType</td>
			<td><code>string</code></td>
			<td><p>The gesture event to listen for.</p></td>
		</tr>
		<tr>
			<td>callback </td>
			<td><code>function(e)</code></td>
			<td><p>The function to call when the gesture happens.</p></td>
		</tr>
		<tr>
			<td>$element </td>
			<td><code>element</code></td>
			<td><p>The angular element to listen for the event on.</p></td>
		</tr>
		<tr>
			<td>options </td>
			<td><code>object</code></td>
			<td><p>object</p></td>
		</tr>
		
		</tbody>
</table>
<p>Returns: <code>ionic.Gesture</code> The gesture object (use this to remove the gesture later on).</p>
<p><code>off(gesture, eventType, callback)</code></p>
<p>Remove an event listener for a gesture on an element. See <code>ionic.EventController</code></p>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>gesture</td>
			<td><code>ionic.Gesture</code></td>
			<td><p>The gesture that should be removed.</p></td>
		</tr>
		<tr>
			<td>eventType</td>
			<td><code>string</code></td>
			<td><p>The gesture event to remove the listener for.</p></td>
		</tr>
		<tr>
			<td>callback </td>
			<td><code>function(e)</code></td>
			<td><p>The listener to remove.</p></td>
		</tr>
		</tbody>
</table>
<!-- headers and footers -->
<h2>headers/Footers</h2>
<h3>ion-header-bar</h3>
<p>Adds a fixed header bar above some content.</p>

<p>Can also be a subheader (lower down) if the ‘bar-subheader’ class is applied. See the header CSS docs.</p>
<h4>Usage</h4>
<pre>
&lt;ion-header-bar align-title=&quot;left&quot; class=&quot;bar-positive&quot;&gt;
  &lt;div class=&quot;buttons&quot;&gt;
    &lt;button class=&quot;button&quot; ng-click=&quot;doSomething()&quot;&gt;Left Button&lt;/button&gt;
  &lt;/div&gt;
  &lt;h1 class=&quot;title&quot;&gt;Title!&lt;/h1&gt;
  &lt;div class=&quot;buttons&quot;&gt;
    &lt;button class=&quot;button&quot;&gt;Right Button&lt;/button&gt;
  &lt;/div&gt;
&lt;/ion-header-bar&gt;
&lt;ion-content class=&quot;has-header&quot;&gt;
  Some content!
&lt;/ion-content&gt;
</pre>
<h4>API</h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Attr</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>align-title <div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>How to align the title. By default the title will be aligned the same as how the platform aligns its titles (iOS centers titles, Android aligns them left). Available: 'left', 'right', or 'center'. Defaults to the same as the platform.</p></td>
		</tr>
		<tr>
			<td>on-tap-scroll <div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>By default, the header bar will scroll the content to the top when tapped. Set no-tap-scroll to true to disable this behavior. Available: true or false. Defaults to false.</p></td>
		</tr>
		</tbody>
		</table>

		<!-- ion ffoter bar -->

		<h3>ion-footer-bar</h3>
<p>Adds a fixed footer bar below some content.</p>

<p>Can also be a subfooter (higher up) if the ‘bar-subfooter’ class is applied. See the footer CSS docs.</p>

<p>Note: If you use ionFooterBar in combination with ng-if, the surrounding content will not align correctly. This will be fixed soon.</p>

<h4>Usage</h4>
<pre>
&lt;ion-content class=&quot;has-footer&quot;&gt;
  Some content!
&lt;/ion-content&gt;
&lt;ion-footer-bar align-title=&quot;left&quot; class=&quot;bar-assertive&quot;&gt;
  &lt;div class=&quot;buttons&quot;&gt;
    &lt;button class=&quot;button&quot;&gt;Left Button&lt;/button&gt;
  &lt;/div&gt;
  &lt;h1 class=&quot;title&quot;&gt;Title!&lt;/h1&gt;
  &lt;div class=&quot;buttons&quot; ng-click=&quot;doSomething()&quot;&gt;
    &lt;button class=&quot;button&quot;&gt;Right Button&lt;/button&gt;
  &lt;/div&gt;
&lt;/ion-footer-bar&gt;
</pre>
<h4>API</h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Attr</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>align-title <div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>Where to align the title. Available: 'left', 'right', or 'center'. Defaults to 'center'.</p></td>
		</tr>
		</tbody>
		</table>
		<!-- keyboard -->
<h2>Keyboard</h2>
<h3>keyboard</h3>
<p>On both Android and iOS, Ionic will attempt to prevent the keyboard from obscuring inputs and focusable elements when it appears by scrolling them into view. In order for this to work, any focusable elements must be within a Scroll View or a directive such as Content that has a Scroll View.</p>

<p>It will also attempt to prevent the native overflow scrolling on focus, which can cause layout issues such as pushing headers up and out of view.</p>

<p>The keyboard fixes work best in conjunction with the Ionic Keyboard Plugin, although it will perform reasonably well without. However, if you are using Cordova there is no reason not to use the plugin.</p>
<h3>Hide when keyboard shows</h3>
<p>To hide an element when the keyboard is open, add the class <code>hide-on-keyboard-open.</code></p>
<pre>
&lt;div class=&quot;hide-on-keyboard-open&quot;&gt;
  &lt;div id=&quot;google-map&quot;&gt;&lt;/div&gt;
&lt;/div&gt;</pre>
<p><strong>Note:</strong> For performance reasons, elements will not be hidden for 400ms after the start of the native.keyboardshow event from the Ionic Keyboard plugin. If you would like them to disappear immediately, you could do something like:</p>
<pre>window.addEventListener(&apos;native.keyboardshow&apos;, function(){
    document.body.classList.add(&apos;keyboard-open&apos;);
  });</pre>
<p>This adds the same keyboard-open class that is normally added by Ionic 400ms after the keyboard opens. However, bear in mind that adding this class to the body immediately may cause jank in any animations on Android that occur when the keyboard opens (for example, scrolling any obscured inputs into view).</p>
<h4>Android Notes</h4>
<p>If your app is running in fullscreen, i.e. you have <code>preference name="Fullscreen" value="true" </code> in your <code>config.xml</code> file you will need to set <code>ionic.Platform.isFullScreen = true</code> manually.</p>

<p>You can configure the behavior of the web view when the keyboard shows by setting android:windowSoftInputMode to either <code>adjustPan</code>, <code>adjustResize</code> or <code>adjustNothing</code> in your app’s activity in <code>AndroidManifest.xml</code>. <code>adjustResize</code> is the recommended setting for Ionic, but if for some reason you do use <code>adjustPan</code> you will need to set <code>ionic.Platform.isFullScreen = true</code>.</p>

<pre>
&lt;activity android:windowSoftInputMode=&quot;adjustResize&quot;&gt;</pre>
<h4>IOS Notes</h4>
<p>If the content of your app (including the header) is being pushed up and out of view on input focus, try setting <code>cordova.plugins.Keyboard.disableScroll(true)</code>. This does not disable scrolling in the Ionic scroll view, rather it disables the native overflow scrolling that happens automatically as a result of focusing on inputs below the keyboard.</p>

<h3>Keyboard-attach</h3>
<p>keyboard-attach is an attribute directive which will cause an element to float above the keyboard when the keyboard shows. Currently only supports the ion-footer-bar directive.</p>
<h4>Notes</h4>

<p>This directive requires the Ionic Keyboard Plugin.</p>
<p>On Android not in fullscreen mode, i.e. you have <code>preference name="Fullscreen" value="false" </code> or no preference in your <code>config.xml</code> file, this directive is unnecessary since it is the default behavior.</p>
<p>On iOS, if there is an input in your footer, you will need to set <code>cordova.plugins.Keyboard.disableScroll(true)</code>.</p>
<h4>Usage</h4>
<pre>
&lt;ion-footer-bar align-title=&quot;left&quot; keyboard-attach class=&quot;bar-assertive&quot;&gt;
   &lt;h1 class=&quot;title&quot;&gt;Title!&lt;/h1&gt;
&lt;/ion-footer-bar&gt;</pre>

<!-- lists -->
<h2>List</h2>
<h3>ion-list</h3>
<p>The List is a widely used interface element in almost any mobile app, and can include content ranging from basic text all the way to buttons, toggles, icons, and thumbnails.</p>

<p>Both the list, which contains items, and the list items themselves can be any HTML element. The containing element requires the <code>list</code> class and each list item requires the <code>item</code> class.</p>

<p>However, using the ionList and ionItem directives make it easy to support various interaction modes such as swipe to edit, drag to reorder, and removing items.</p>

<p>Related: <code>ionItem</code>, <code>ionOptionButton</code> <code>ionReorderButton</code>, <code>ionDeleteButton</code>, <code>list CSS documentation</code>.</p>
<h4>Usage</h4>
<p>basic usage</p>
<pre>
&lt;ion-list&gt;
  &lt;ion-item ng-repeat=&quot;item in items&quot;&gt;
    Hello, {{item}}!
  &lt;/ion-item&gt;
&lt;/ion-list&gt;&gt;</pre>
<p>Advanced Usage: Thumbnails, Delete buttons, Reordering, Swiping</p>
<pre>
&lt;ion-list ng-controller=&quot;MyCtrl&quot;
          show-delete=&quot;shouldShowDelete&quot;
          show-reorder=&quot;shouldShowReorder&quot;
          can-swipe=&quot;listCanSwipe&quot;&gt;
  &lt;ion-item ng-repeat=&quot;item in items&quot;
            class=&quot;item-thumbnail-left&quot;&gt;

    &lt;img ng-src=&quot;{{item.img}}&quot;&gt;
    &lt;h2&gt;{{item.title}}&lt;/h2&gt;
    &lt;p&gt;{{item.description}}&lt;/p&gt;
    &lt;ion-option-button class=&quot;button-positive&quot;
                       ng-click=&quot;share(item)&quot;&gt;
      Share
    &lt;/ion-option-button&gt;
    &lt;ion-option-button class=&quot;button-info&quot;
                       ng-click=&quot;edit(item)&quot;&gt;
      Edit
    &lt;/ion-option-button&gt;
    &lt;ion-delete-button class=&quot;ion-minus-circled&quot;
                       ng-click=&quot;items.splice($index, 1)&quot;&gt;
    &lt;/ion-delete-button&gt;
    &lt;ion-reorder-button class=&quot;ion-navicon&quot;
                        on-reorder=&quot;reorderItem(item, $fromIndex, $toIndex)&quot;&gt;
    &lt;/ion-reorder-button&gt;

  &lt;/ion-item&gt;
&lt;/ion-list&gt;</pre>
<pre>app.controller(&apos;MyCtrl&apos;, function($scope) {
 $scope.shouldShowDelete = false;
 $scope.shouldShowReorder = false;
 $scope.listCanSwipe = true
});</pre>

<h4>API</h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Attr</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>delegate-handle <div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>The handle used to identify this list with <code>$ionicListDelegate</code>.</p></td>
		</tr>
		<tr>
			<td>type <div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>The type of list to use (list-inset or card)</p></td>
		</tr>
		<tr>
			<td>show-delete <div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>Whether the delete buttons for the items in the list are currently shown or hidden.</p></td>
		</tr>
		<tr>
			<td>show-reorder <div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>Whether the reorder buttons for the items in the list are currently shown or hidden.</p></td>
		</tr>
		<tr>
			<td>can-swipe <div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>Whether the items in the list are allowed to be swiped to reveal option buttons. Default: true.</p></td>
		</tr>
		</tbody>
		</table>
<h3>ion-item</h3>
<p>Child of <code>ionList</code></p>
<h4>Usage</h4>
<pre>&lt;ion-list&gt;
  &lt;ion-item&gt;Hello!&lt;/ion-item&gt;
  &lt;ion-item href=&quot;#/detail&quot;&gt;
    Link to detail page
  &lt;/ion-item&gt;
&lt;/ion-list&gt;</pre>

<h3>Ion-delete-button</h3>
<p>Child of <code>IonItem</code></p>
<h4>Usage</h4>
<pre>
&lt;ion-list show-delete=&quot;shouldShowDelete&quot;&gt;
  &lt;ion-item&gt;
    &lt;ion-delete-button class=&quot;ion-minus-circled&quot;&gt;&lt;/ion-delete-button&gt;
    Hello, list item!
  &lt;/ion-item&gt;
&lt;/ion-list&gt;
&lt;ion-toggle ng-model=&quot;shouldShowDelete&quot;&gt;
  Show Delete?
&lt;/ion-toggle&gt;</pre>

<h3>ion-reorder-button</h3>
<p>Child of <code>ionItem</code></p>
<h4>Usage</h4>
<pre>
&lt;ion-list ng-controller=&quot;MyCtrl&quot; show-reorder=&quot;true&quot;&gt;
  &lt;ion-item ng-repeat=&quot;item in items&quot;&gt;
    Item 
    &lt;ion-reorder-button class=&quot;ion-navicon&quot;
                        on-reorder=&quot;moveItem(item, $fromIndex, $toIndex)&quot;&gt;
    &lt;/ion-reorder-button&gt;
  &lt;/ion-item&gt;
&lt;/ion-list&gt;</pre>
<pre>
function MyCtrl($scope) {
  $scope.items = [1, 2, 3, 4];
  $scope.moveItem = function(item, fromIndex, toIndex) {
    //Move the item in the array
    $scope.items.splice(fromIndex, 1);
    $scope.items.splice(toIndex, 0, item);
  };
}</pre>
<h4>API</h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Attr</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>on-reorder <div><em>(optional)</em></div></td>
			<td><code>expression</code></td>
			<td><p>Expression to call when an item is reordered. Parameters given: $fromIndex, $toIndex.</p></td>
		</tr>
		</tbody>
		</table>
<h3>ion-option button</h3>
<p>Creates an option button inside a list item, that is visible when the item is swiped to the left by the user. Swiped open option buttons can be hidden with $ionicListDelegate.closeOptionButtons.</p>

<p>Can be assigned any button class.</p>

<p>See <code>ionList</code> for a complete example & explanation.</p>
<h4>Usage</h4>
<pre>
&lt;ion-list&gt;
  &lt;ion-item&gt;
    I love kittens!
    &lt;ion-option-button class=&quot;button-positive&quot;&gt;Share&lt;/ion-option-button&gt;
    &lt;ion-option-button class=&quot;button-assertive&quot;&gt;Edit&lt;/ion-option-button&gt;
  &lt;/ion-item&gt;
&lt;/ion-list&gt;</pre>

<h3>Collection-repeat</h3>
<p><code>collection-repeat</code> allows an app to show huge lists of items much more performantly than <code>ng-repeat</code>.</p>

<p>It renders into the DOM only as many items as are currently visible.</p>

<p>This means that on a phone screen that can fit eight items, only the eight items matching the current scroll position will be rendered.</p>
<h4><strong>Basics:</strong></h4>
<p>The data given to collection-repeat must be an array.</p>
<p>If the <code>item-height</code> and <code>item-width</code> attributes are not supplied, it will be assumed that every item in the list has the same dimensions as the first item.</p>
<p>Don’t use angular one-time binding <code>(::)</code> with collection-repeat. The scope of each item is assigned new data and re-digested as you scroll. Bindings need to update, and one-time bindings won’t.</p>

<h4><strong>Performance Tips:</strong></h4>
<p>he iOS webview has a performance bottleneck when switching out <code>img src</code> attributes. To increase performance of images on iOS, cache your images in advance and, if possible, lower the number of unique images. We’re working on a solution.</p>
<h4>Usage</h4>
<p>Basic item list</p>
<pre>
&lt;ion-list&gt;
  &lt;ion-item&gt;
    I love kittens!
    &lt;ion-option-button class=&quot;button-positive&quot;&gt;Share&lt;/ion-option-button&gt;
    &lt;ion-option-button class=&quot;button-assertive&quot;&gt;Edit&lt;/ion-option-button&gt;
  &lt;/ion-item&gt;
&lt;/ion-list&gt;</pre>
<p>Grid of Images</p>
<pre>
&lt;ion-content&gt;
  &lt;img collection-repeat=&quot;photo in photos&quot;
    item-width=&quot;33%&quot;
    item-height=&quot;200px&quot;
    ng-src=&quot;{{photo.url}}&quot;&gt;
&lt;/ion-content&gt;</pre>
<p>Horizontal scroller, Dynamic Item Width</p>
<pre>
&lt;ion-content&gt;
  &lt;h2&gt;Available Kittens:&lt;/h2&gt;
  &lt;ion-scroll direction=&quot;x&quot; class=&quot;available-scroller&quot;&gt;
    &lt;div class=&quot;photo&quot; collection-repeat=&quot;photo in main.photos&quot;
       item-height=&quot;250&quot; item-width=&quot;photo.width + 30&quot;&gt;
       &lt;img ng-src=&quot;{{photo.src}}&quot;&gt;
    &lt;/div&gt;
  &lt;/ion-scroll&gt;
&lt;/ion-content&gt;</pre>
<h4>API</h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Attr</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>collection-repeat </td>
			<td><code>expression</code></td>
			<td><p>The expression indicating how to enumerate a collection, of the format <code>variable in expression</code> – where variable is the user defined loop variable and <code>expression</code> is a scope expression giving the collection to enumerate. For example: <code>album in artist.albums</code> or <code>album in artist.albums | orderBy:'name'</code>.</p></td>
		</tr>
		<tr>
			<td>item-width <div><em>(optional)</em></div></td>
			<td><code>expression</code></td>
			<td><p>The width of the repeated element. The expression must return a number (pixels) or a percentage. Defaults to the width of the first item in the list. (previously named collection-item-width)</p></td>
		</tr>
		<tr>
			<td>item-height<div><em>(optional)</em></div></td>
			<td><code>expression</code></td>
			<td><p>The height of the repeated element. The expression must return a number (pixels) or a percentage. Defaults to the height of the first item in the list. (previously named collection-item-height)</p></td>
		</tr>
		<tr>
			<td>item-render-buffer <div><em>(optional)</em></div></td>
			<td><code>number</code></td>
			<td><p>The number of items to load before and after the visible items in the list. Default 3. Tip: set this higher if you have lots of images to preload, but don't set it too high or you'll see performance loss.</p></td>
		</tr>
		<tr>
			<td>force-refresh-images <div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>Force images to refresh as you scroll. This fixes a problem where, when an element is interchanged as scrolling, its image will still have the old src while the new src loads. Setting this to true comes with a small performance loss.</p></td>
		</tr>
		</tbody>
		</table>

<h3>$ionicListDelegate</h3>
<p>Delegate for controlling the <code>ionList</code> directive.</p>

<p>Methods called directly on the $ionicListDelegate service will control all lists. Use the $getByHandle method to control specific ionList instances.</p>
<h4>Usage</h4>
<pre>
&lt;ion-content ng-controller=&quot;MyCtrl&quot;&gt;
  &lt;button class=&quot;button&quot; ng-click=&quot;showDeleteButtons()&quot;&gt;&lt;/button&gt;
  &lt;ion-list&gt;
    &lt;ion-item ng-repeat=&quot;i in items&quot;&gt;
      Hello, {{i}}!
      &lt;ion-delete-button class=&quot;ion-minus-circled&quot;&gt;&lt;/ion-delete-button&gt;
    &lt;/ion-item&gt;
  &lt;/ion-list&gt;
&lt;/ion-content&gt;</pre>
<pre>function MyCtrl($scope, $ionicListDelegate) {
  $scope.showDeleteButtons = function() {
    $ionicListDelegate.showDelete(true);
  };
}</pre>
<h4>Methods</h4>
<code>showReorder([showReorder])</code>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>showReorder<div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>Set whether or not this list is showing its reorder buttons.</p></td>
		</tr>
		</tbody>
		</table>
<p>Returns: <code>boolean</code> Whether the reorder buttons are shown.</p>
<p><code>showDelete([showDelete])</code></p>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>showDelete<div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>Set whether or not this list is showing its delete buttons.</p></td>
		</tr>
		</tbody>
		</table>
<p>Returns: <code>boolean</code> Whether the delete buttons are shown.</p>
<p><code>canSwipeItems([canSwipeItems])</code></p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>canSwipeItems<div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>Set whether or not this list is able to swipe to show option buttons.</p></td>
		</tr>
		</tbody>
		</table>
<p>Returns: boolean Whether the list is able to swipe to show option buttons.</p>
<p><code>closeOptionButtons()</code></p>
<p>Closes any option buttons on the list that are swiped open.</p>

<p><code>$getByHandle(handle)</code></p>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>handle</td>
			<td><code>string</code></td>
			<td><p></p></td>
		</tr>
		</tbody>
		</table>
<p>Returns: <code>delegateInstance</code> A delegate instance that controls only the <code>ionList</code> directives with <code>delegate-handle</code> matching the given handle.</p>
<p>Example: <code>$ionicListDelegate.$getByHandle('my-handle').showReorder(true)</code>;</p>

<!-- loading -->
<h2>Loading</h2>
<h3>$ionicLoading</h3>
<p>An overlay that can be used to indicate activity while blocking user interaction.</p>
<h4>Usage</h4>
<pre>
angular.module(&apos;LoadingApp&apos;, [&apos;ionic&apos;])
.controller(&apos;LoadingCtrl&apos;, function($scope, $ionicLoading) {
  $scope.show = function() {
    $ionicLoading.show({
      template: &apos;Loading...&apos;
    }).then(function(){
       console.log(&quot;The loading indicator is now displayed&quot;);
    });
  };
  $scope.hide = function(){
    $ionicLoading.hide().then(function(){
       console.log(&quot;The loading indicator is now hidden&quot;);
    });
  };
});</pre>
<h4>Methods</h4>
<p><code>show(opts)</code></p>
<p>Shows a loading indicator. If the indicator is already shown, it will set the options given and keep the indicator shown.</p>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>opts</td>
			<td><code>object</code></td>
			<td><p>The options for the loading indicator. Available properties:</p>
			<p><code>{string=}</code> <code>template</code> The html content of the indicator.</p>
			<p><code>{string=}</code> <code>templateUrl</code> The url of an html template to load as the content of the indicator.</p>
			<p><code>{object=}</code> <code>scope</code> The scope to be a child of. Default: creates a child of $rootScope.</p>
			<p><code>{boolean=}</code> <code>noBackdrop</code> Whether to hide the backdrop. By default it will be shown.</p>
			<p><code>{boolean=}</code> <code>hideOnStateChange</code> Whether to hide the loading spinner when navigating to a new state. Default false.</p>
			<p><code>{number=}</code> <code>delay</code> How many milliseconds to delay showing the indicator. By default there is no delay.</p>
			<p><code>{number=}</code> <code>duration</code> How many milliseconds to wait until automatically hiding the indicator. By default, the indicator will be shown until <code>.hide()</code> is called.</p>
			</td>
		</tr>
		</tbody>
		</table>
<p>Returns: <code>promise</code> A promise which is resolved when the loading indicator is presented.</p>
<p><h4><code>hide()</code></h4>
<p>Hides the loading indicator, if shown.</p>

<p>Returns: <code>promise</code> A promise which is resolved when the loading indicator is hidden.</p>

<h3>$ionicLoadingConfig</h3>
<p>Set the default options to be passed to the <code>$ionicLoading</code> service.</p>
<h4>Usage</h4>
<pre>
var app = angular.module(&apos;myApp&apos;, [&apos;ionic&apos;])
app.constant(&apos;$ionicLoadingConfig&apos;, {
  template: &apos;Default Loading Template...&apos;
});
app.controller(&apos;AppCtrl&apos;, function($scope, $ionicLoading) {
  $scope.showLoading = function() {
    //options default to values in $ionicLoadingConfig
    $ionicLoading.show().then(function(){
       console.log(&quot;The loading indicator is now displayed&quot;);
    });
  };
});</pre>
 
 <!-- modal -->
 <h2>Modal</h2>
 <h3>$ionicModal</h3>
<p>The Modal is a content pane that can go over the user’s main view temporarily. Usually used for making a choice or editing an item.</p>

<p>Put the content of the modal inside of an <code>ion-modal-view</code> element.</p>
<p><strong>Notes:</strong> - A modal will broadcast ‘modal.shown’, ‘modal.hidden’, and ‘modal.removed’ events from its originating scope, passing in itself as an event argument. Both the modal.removed and modal.hidden events are called when the modal is removed.</p>

<p>This example assumes your modal is in your main index file or another template file. If it is in its own template file, remove the script tags and call it by file name.</p>
<h4>Usage</h4>
<pre>
&lt;script id=&quot;my-modal.html&quot; type=&quot;text/ng-template&quot;&gt;
  &lt;ion-modal-view&gt;
    &lt;ion-header-bar&gt;
      &lt;h1 class=&quot;title&quot;&gt;My Modal title&lt;/h1&gt;
    &lt;/ion-header-bar&gt;
    &lt;ion-content&gt;
      Hello!
    &lt;/ion-content&gt;
  &lt;/ion-modal-view&gt;
&lt;/script&gt;</pre>
<pre>
angular.module(&apos;testApp&apos;, [&apos;ionic&apos;])
.controller(&apos;MyController&apos;, function($scope, $ionicModal) {
  $ionicModal.fromTemplateUrl(&apos;my-modal.html&apos;, {
    scope: $scope,
    animation: &apos;slide-in-up&apos;
  }).then(function(modal) {
    $scope.modal = modal;
  });
  $scope.openModal = function() {
    $scope.modal.show();
  };
  $scope.closeModal = function() {
    $scope.modal.hide();
  };
  // Cleanup the modal when we&apos;re done with it!
  $scope.$on(&apos;$destroy&apos;, function() {
    $scope.modal.remove();
  });
  // Execute action on hide modal
  $scope.$on(&apos;modal.hidden&apos;, function() {
    // Execute action
  });
  // Execute action on remove modal
  $scope.$on(&apos;modal.removed&apos;, function() {
    // Execute action
  });
});</pre>
<h4>Methods</h4>

<p><code>fromTemplate(templateString, options)</code></p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>templateString<div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>The template string to use as the modal's content.</p></td>
		</tr>
		<tr>
			<td>Options<div><em>(optional)</em></div></td>
			<td><code>object</code></td>
			<td><p>Options to be passed ionicModal#initialize method.</p></td>
		</tr>
		</tbody>
		</table>
<p>Returns: <code>object</code> An instance of an <code>ionicModal</code> controller.</p>
<p><code>fromTemplateUrl(templateUrl, options)</code></p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>templateUrl<div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>The url to load the template from.</p></td>
		</tr>
		<tr>
			<td>Options<div><em>(optional)</em></div></td>
			<td><code>object</code></td>
			<td><p>Options to be passed ionicModal#initialize method. options object.</p></td>
		</tr>
		</tbody>
		</table>
<p>Returns: <code>promise</code> A promise that will be resolved with an instance of an <code>ionicModal</code> controller.</p>

<h3>ionicModal</h3>
<p>Instantiated by the <code>$ionicModal</code> service.</p>

<p>Be sure to call remove() when you are done with each modal to clean it up and avoid memory leaks.</p>

<p>Note: a modal will broadcast ‘modal.shown’, ‘modal.hidden’, and ‘modal.removed’ events from its originating scope, passing in itself as an event argument. Note: both modal.removed and modal.hidden are called when the modal is removed.</p>
<h4>Methods</h4>
<p><code><h4>initialize(options)</h4></code>
<p>Creates a new modal controller instance.</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>opts</td>
			<td><code>object</code></td>
			<td><p>An options object with the following properties:</p>
			<p><code>{object=}</code> <code>scope</code> The scope to be a child of. Default: creates a child of $rootScope.</p>
			<p><code>{string=}</code> <code>animation</code> The animation to show & hide with. Default: 'slide-in-up'</p>
			<p><code>{boolean=}</code> <code>focusFirstInput</code> Whether to autofocus the first input of the modal when shown. Will only show the keyboard on iOS, to force the keyboard to show on Android, please use the Ionic keyboard plugin. Default: false.</p>
			<p><code>{boolean=}</code> <code>backdropClickToClose</code>  Whether to close the modal on clicking the backdrop. Default: true.</p>
			<p><code>{boolean=}</code> <code>hideOnStateChange</code> Whether to hide the loading spinner when navigating to a new state. Default false.</p>
			<p><code>{boolean=}</code> <code>delay</code> How many milliseconds to delay showing the indicator. By default there is no delay.</p>
			<p><code>{boolean=}</code> <code>hardwareBackButtonClose</code> Whether the modal can be closed using the hardware back button on Android and similar devices. Default: true.</p>
			</td>
		</tr>
		</tbody>
		</table>
<p><h4><code>show()</code></h4></p>
<p>Show this modal instance.</p>
<p>Returns: <code>promise</code> A promise which is resolved when the modal is finished animating in.</p>
<p><h4><code>hide()</code></h4></p>
<p>Hide this modal instance.</p>

<p>Returns: <code>promise</code> A promise which is resolved when the modal is finished animating out.</p>
<p><h4><code>remove()</code></h4></p>
<p>Remove this modal instance from the DOM and clean up.</p>

<p>Returns: <code>promise</code> A promise which is resolved when the modal is finished animating out.</p>
<p><h4><code>isShown()</code></h4></p>
<p>Returns: boolean Whether this modal is currently shown.</p>

<h2>Navigation</h2>
<h3>ion-nav-view</h3>
<p>As a user navigates throughout your app, Ionic is able to keep track of their navigation history. By knowing their history, transitions between views correctly enter and exit using the platform’s transition style. An additional benefit to Ionic’s navigation system is its ability to manage multiple histories. For example, each tab can have it’s own navigation history stack.</p>

<p>Ionic uses the AngularUI Router module so app interfaces can be organized into various “states”. Like Angular’s core $route service, URLs can be used to control the views. However, the AngularUI Router provides a more powerful state manager in that states are bound to named, nested, and parallel views, allowing more than one template to be rendered on the same page. Additionally, each state is not required to be bound to a URL, and data can be pushed to each state which allows much flexibility.</p>

<p>The ionNavView directive is used to render templates in your application. Each template is part of a state. States are usually mapped to a url, and are defined programatically using angular-ui-router (see their docs, and remember to replace ui-view with ion-nav-view in examples).</p>

<h4>Usage</h4>
<p>In this example, we will create a navigation view that contains our different states for the app.</p>

<p>To do this, in our markup we use ionNavView top level directive. To display a header bar we use the <code>ionNavBar</code> directive that updates as we navigate through the navigation stack.</p>

<p>Next, we need to setup our states that will be rendered.</p>
<pre>
var app = angular.module(&apos;myApp&apos;, [&apos;ionic&apos;]);
app.config(function($stateProvider) {
  $stateProvider
  .state(&apos;index&apos;, {
    url: &apos;/&apos;,
    templateUrl: &apos;home.html&apos;
  })
  .state(&apos;music&apos;, {
    url: &apos;/music&apos;,
    templateUrl: &apos;music.html&apos;
  });
});</pre>
<p>Then on app start, $stateProvider will look at the url, see if it matches the index state, and then try to load home.html into the <code>ion-nav-view</code>.</p>

<p>Pages are loaded by the URLs given. One simple way to create templates in Angular is to put them directly into your HTML file and use the <code>script type="text/ng-template"</code> syntax. So here is one way to put home.html into our app:</p>
<pre>
&lt;script id=&quot;home&quot; type=&quot;text/ng-template&quot;&gt;
  &lt;!-- The title of the ion-view will be shown on the navbar --&gt;
  &lt;ion-view view-title=&quot;Home&quot;&gt;
    &lt;ion-content ng-controller=&quot;HomeCtrl&quot;&gt;
      &lt;!-- The content of the page --&gt;
      &lt;a href=&quot;#/music&quot;&gt;Go to music page!&lt;/a&gt;
    &lt;/ion-content&gt;
  &lt;/ion-view&gt;
&lt;/script&gt;</pre>
<p>This is good to do because the template will be cached for very fast loading, instead of having to fetch them from the network.</p>

<h4>Caching</h4>
<p>By default, views are cached to improve performance. When a view is navigated away from, its element is left in the DOM, and its scope is disconnected from the <code>$watch</code> cycle. When navigating to a view that is already cached, its scope is then reconnected, and the existing element that was left in the DOM becomes the active view. This also allows for the scroll position of previous views to be maintained.</p>

<p>Caching can be disabled and enabled in multiple ways. By default, Ionic will cache a maximum of 10 views, and not only can this be configured, but apps can also explicitly state which views should and should not be cached.</p>

<p>Note that because we are caching these views, we aren’t destroying scopes. Instead, scopes are being disconnected from the watch cycle. Because scopes are not being destroyed and recreated, controllers are not loading again on a subsequent viewing. If the app/controller needs to know when a view has entered or has left, then view events emitted from the <code>ionView</code> scope, such as <code>$ionicView.enter</code>, may be useful.</p>

<p>By default, when navigating back in the history, the “forward” views are removed from the cache. If you navigate forward to the same view again, it’ll create a new DOM element and controller instance. Basically, any forward views are reset each time. This can be configured using the <code>$ionicConfigProvider:</code></p>
<pre>$ionicConfigProvider.views.forwardCache(true);</pre>
<h4>Disable cache globally</h4>

<p>The <code>$ionicConfigProvider</code> can be used to set the maximum allowable views which can be cached, but this can also be use to disable all caching by setting it to 0.</p>
<pre>$ionicConfigProvider.views.maxCache(0);</pre>
<p>Disable cache within state provider</p>
<pre>
$stateProvider.state(&apos;myState&apos;, {
   cache: false,
   url : &apos;/myUrl&apos;,
   templateUrl : &apos;my-template.html&apos;
})</pre>
<p>Disable cache with an attribute</p>
<pre>
&lt;ion-view cache-view=&quot;false&quot; view-title=&quot;My Title!&quot;&gt;
  ...
&lt;/ion-view&gt;</pre>
<h4>API</h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Attr</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>name<div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>A view name. The name should be unique amongst the other views in the same state. You can have views of the same name that live in different states. For more information, see ui-router's ui-view documentation.

</p></td>
		</tr>
		</tbody>
		</table>

<h3>ion-view</h3>
<p>Child of <code>ionNavView</code></p>
<p>A container for view content and any navigational and header bar information. When a view enters and exits its parent <code>ionNavView</code>, the view also emits view information, such as its title, whether the back button should be displayed or not, whether the corresponding <code>ionNavBar</code> should be displayed or not, which transition the view should use to animate, and which direction to animate.</p>/

<p>Views are cached to improve performance. When a view is navigated away from, its element is left in the DOM, and its scope is disconnected from the <code>$watch</code> cycle. When navigating to a view that is already cached, its scope is reconnected, and the existing element, which was left in the DOM, becomes active again. This can be disabled, or the maximum number of cached views changed in <code>$ionicConfigProvider</code>, in the view’s <code>$state</code> configuration, or as an attribute on the view itself (see below).</p>

<h4>Usage</h4>
<p>Below is an example where our page will load with a <code>ionNavBar</code> containing “My Page” as the title.</p>
<pre>
&lt;ion-nav-bar&gt;&lt;/ion-nav-bar&gt;
&lt;ion-nav-view&gt;
  &lt;ion-view view-title=&quot;My Page&quot;&gt;
    &lt;ion-content&gt;
      Hello!
    &lt;/ion-content&gt;
  &lt;/ion-view&gt;
&lt;/ion-nav-view&gt;</pre>

<h4>View LifeCycle and Events</h4>
<p>Views can be cached, which means <strong>controllers normally only load once</strong>, which may affect your controller logic. To know when a view has entered or left, events have been added that are emitted from the view’s scope. These events also contain data about the view, such as the title and whether the back button should show. Also contained is transition data, such as the transition type and direction that will be or was used.</p>

<p>Life cycle events are emitted upwards from the transitioning view’s scope. In some cases, it is desirable for a child/nested view to be notified of the event. For this use case, <code>$ionicParentView</code> life cycle events are broadcast downwards.</p>

<table class="jtable" style="margin:10;">
	
	<tbody>
		<tr>
			
			<td><code>$ionicView.loaded</code></td>
			<td><p>The view has loaded. This event only happens once per view being created and added to the DOM. If a view leaves but is cached, then this event will not fire again on a subsequent viewing. The loaded event is good place to put your setup code for the view; however, it is not the recommended event to listen to when a view becomes active.</p></td>
		</tr>

		<tr>
		<td><code>$ionicView.enter</code></td>
			<td><p>The view has fully entered and is now the active view. This event will fire, whether it was the first load or a cached view.</p></td>
		</tr>

		<tr>
		<td><code>$ionicView.leave</code></td>
			<td><p>The view has finished leaving and is no longer the active view. This event will fire, whether it is cached or destroyed.</p></td>
		</tr>

		<tr>
		<td><code>$ionicView.beforeEnter</code></td>
			<td><p>The view is about to enter and become the active view.
			</p></td>
		</tr>

		<tr>
		<td><code>$ionicView.beforeLeave</code></td>
			<td><p>The view is about to leave and no longer be the active view.
			</p></td>
		</tr>

		<tr>
		<td><code>$ionicView.afterEnter</code></td>
			<td><p>The view has fully entered and is now the active view.
			</p></td>
		</tr>

		<tr>
		<td><code>$ionicView.afterLeave</code></td>
			<td><p>The view has finished leaving and is no longer the active view.
			</p></td>
		</tr>

		<tr>
		<td><code>$ionicView.unloaded</code></td>
			<td><p>The view's controller has been destroyed and its element has been removed from the DOM.
			</p></td>
		</tr>

		<tr>
		<td><code>$ionicParentView.enter</code></td>
			<td><p>The parent view has fully entered and is now the active view. This event will fire, whether it was the first load or a cached view.
			</p></td>
		</tr>

		<tr>
		<td><code>$ionicParentView.leave</code></td>
			<td><p>The parent view has finished leaving and is no longer the active view. This event will fire, whether it is cached or destroyed.
			</p></td>
		</tr>

		<tr>
		<td><code>$ionicParentView.beforeEnter</code></td>
			<td><p>The parent view is about to enter and become the active view.
			</p></td>
		</tr>

		<tr>
		<td><code>$ionicParentView.beforeLeave</code></td>
			<td><p>The parent view is about to leave and no longer be the active view.
			</p></td>
		</tr>

		<tr>
		<td><code>$ionicParenView.afterEnter</code></td>
			<td><p>The parent view has fully entered and is now the active view.
			</p></td>
		</tr>

		<tr>
		<td><code>$ionicParentView.afterLeave</code></td>
			<td><p>The parent view has finished leaving and is no longer the active view.
			</p></td>
		</tr>

		</tbody>
		</table>

<h4>LifeCycle Event Usage</h4>
<p>Below is an example of how to listen to life cycle events and access state parameter data</p>
<pre>$scope.$on(&quot;$ionicView.beforeEnter&quot;, function(event, data){
   // handle event
   console.log(&quot;State Params: &quot;, data.stateParams);
});

$scope.$on(&quot;$ionicView.enter&quot;, function(event, data){
   // handle event
   console.log(&quot;State Params: &quot;, data.stateParams);
});

$scope.$on(&quot;$ionicView.afterEnter&quot;, function(event, data){
   // handle event
   console.log(&quot;State Params: &quot;, data.stateParams);
});</pre>

<h4>Caching</h4>
<p>Caching can be disabled and enabled in multiple ways. By default, Ionic will cache a maximum of 10 views. You can optionally choose to disable caching at either an individual view basis, or by global configuration. Please see the Caching section in <code>ionNavView</code> for more info.</p>
<h4>API</h4>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Attr</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>view-title<div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>A text-only title to display on the parent <code>ionNavBar</code>. For an HTML title, such as an image, see <code>ionNavTitle</code> instead.
</p></td>
		</tr>
		<tr>
			<td>cache-view<div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>If this view should be allowed to be cached or not. Please see the Caching section in <code>ionNavView</code> for more info. Default <code>true</code>

</p></td>
		</tr>
		<tr>
			<td>can-swipe-back<div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>If this view should be allowed to use the swipe to go back gesture or not. This does not enable the swipe to go back feature if it is not available for the platform it's running from, or there isn't a previous view. Default <code>true</code>

</p></td>
		</tr>
		<tr>
			<td>hide-back-button<div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>Whether to hide the back button on the parent <code>ionNavBar</code> by default.

</p></td>
		</tr>
		<tr>
			<td>hide-nav-bar<div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>Whether to hide the parent <code>ionNavBar</code> by default.

</p></td>
		</tr>
		</tbody>
		</table>
<h3>ion-nav-bar</h3>
<p>Delegate: <code>$ionicNavBarDelegate</code></p>

<p>If we have an ionNavView directive, we can also create an <code>ion-nav-bar</code>, which will create a topbar that updates as the application state changes.

<p>We can add a back button by putting an ionNavBackButton inside.</p>

<p>We can add buttons depending on the currently visible view using ionNavButtons.</p>

<p>Note that the ion-nav-bar element will only work correctly if your content has an ionView around it.</p>

<pre>
&lt;body ng-app=&quot;starter&quot;&gt;
  &lt;!-- The nav bar that will be updated as we navigate --&gt;
  &lt;ion-nav-bar class=&quot;bar-positive&quot;&gt;
  &lt;/ion-nav-bar&gt;

  &lt;!-- where the initial view template will be rendered --&gt;
  &lt;ion-nav-view&gt;
    &lt;ion-view&gt;
      &lt;ion-content&gt;Hello!&lt;/ion-content&gt;
    &lt;/ion-view&gt;
  &lt;/ion-nav-view&gt;
&lt;/body&gt;</pre>

<h4>API</h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Attr</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>delegate-handle<div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>The handle used to identify this navBar with <code>$ionicNavBarDelegate</code>.
</p></td>
		</tr>
		<tr>
			<td>align-title<div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>Where to align the title of the navbar. Available: 'left', 'right', 'center'. Defaults to 'center'.
</p></td>
		</tr>
		<tr>
			<td>on-tap-scroll<div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>By default, the navbar will scroll the content to the top when tapped. Set no-tap-scroll to true to disable this behavior.

</p></td>
		</tr>
		
		</tbody>
		</table>
<h3>ion-nav-back-button</h3> 
<p>Child of <code>ionNavBar</code></p>

<p>Creates a back button inside an ionNavBar.</p>

<p>The back button will appear when the user is able to go back in the current navigation stack. By default, the markup of the back button is automatically built using platform-appropriate defaults (iOS back button icon on iOS and Android icon on Android).</p>

<p>Additionally, the button is automatically set to $ionicGoBack() on click/tap. By default, the app will navigate back one view when the back button is clicked. More advanced behavior is also possible, as outlined below.</p>

<h4>Usage</h4>
<p>Recommended markup for default settings:</p>
<pre>
&lt;ion-nav-bar&gt;
  &lt;ion-nav-back-button&gt;
  &lt;/ion-nav-back-button&gt;
&lt;/ion-nav-bar&gt;</pre>
<p>With custom inner markup, and automatically adds a default click action:</p>
<pre>
&lt;ion-nav-bar&gt;
  &lt;ion-nav-back-button class=&quot;button-clear&quot;&gt;
    &lt;i class=&quot;ion-arrow-left-c&quot;&gt;&lt;/i&gt; Back
  &lt;/ion-nav-back-button&gt;
&lt;/ion-nav-bar&gt;</pre>
<p>With custom inner markup and custom click action, using <code>$ionicHistory:</code></p>
<pre>
&lt;ion-nav-bar ng-controller=&quot;MyCtrl&quot;&gt;
  &lt;ion-nav-back-button class=&quot;button-clear&quot;
    ng-click=&quot;myGoBack()&quot;&gt;
    &lt;i class=&quot;ion-arrow-left-c&quot;&gt;&lt;/i&gt; Back
  &lt;/ion-nav-back-button&gt;
&lt;/ion-nav-bar&gt;</pre>
<pre>
function MyCtrl($scope, $ionicHistory) {
  $scope.myGoBack = function() {
    $ionicHistory.goBack();
  };
}</pre>

<h3>ion-nav-buttons</h3> 
<p>Child of <code>ionNavView</code></p>

<p>Use nav buttons to set the buttons on your <code>ionNavBar</code> from within an <code>ionView</code>. This gives each view template the ability to specify which buttons should show in the nav bar, overriding any default buttons already placed in the nav bar.</p>

<p>Any buttons you declare will be positioned on the navbar’s corresponding side. Primary buttons generally map to the left side of the header, and secondary buttons are generally on the right side. However, their exact locations are platform-specific. For example, in iOS, the primary buttons are on the far left of the header, and secondary buttons are on the far right, with the header title centered between them. For Android, however, both groups of buttons are on the far right of the header, with the header title aligned left.</p>

<p>We recommend always using <code>primary</code> and <code>secondary</code>, so the buttons correctly map to the side familiar to users of each platform. However, in cases where buttons should always be on an exact side, both <code>left</code> and <code>right</code> sides are still available. For example, a toggle button for a left side menu should be on the left side; in this case, we’d recommend using <code>side="left"</code>, so it’s always on the left, no matter the platform.</p>

<p>Note that <code>ion-nav-buttons</code> must be immediate descendants of the <code>ion-view</code> or <code>ion-nav-bar</code> element (basically, don’t wrap it in another div).</p>

<h4>Usage</h4>
<pre>
&lt;ion-nav-bar&gt;
&lt;/ion-nav-bar&gt;
&lt;ion-nav-view&gt;
  &lt;ion-view&gt;
    &lt;ion-nav-buttons side=&quot;primary&quot;&gt;
      &lt;button class=&quot;button&quot; ng-click=&quot;doSomething()&quot;&gt;
        I&apos;m a button on the primary of the navbar!
      &lt;/button&gt;
    &lt;/ion-nav-buttons&gt;
    &lt;ion-content&gt;
      Some super content here!
    &lt;/ion-content&gt;
  &lt;/ion-view&gt;
&lt;/ion-nav-view&gt;</pre>
<h4>API</h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Attr</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>side<div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>The side to place the buttons in the <code>ionNavBar</code>. Available sides: <code>primary</code>, <code>secondary</code>, <code>left</code>, and <code>right</code>.
</p></td>
		</tr>
		</tbody></table>

<h3>ion-nav-title</h3> 
<p>Child of <code>ionNavView</code></p>

<p>The nav title directive replaces an <code>ionNavBar</code> title text with custom HTML from within an <code>ionView</code> template. This gives each view the ability to specify its own custom title element, such as an image or any HTML, rather than being text-only. Alternatively, text-only titles can be updated using the <code>view-title</code> <code>ionView</code> attribute.</p>

<p>Note that <code>ion-nav-title</code> must be an immediate descendant of the <code>ion-view</code> or <code>ion-nav-bar</code> element (basically don’t wrap it in another div).</p>

<h4>Usage</h4>
<pre>
&lt;ion-nav-bar&gt;
&lt;/ion-nav-bar&gt;
&lt;ion-nav-view&gt;
  &lt;ion-view&gt;
    &lt;ion-nav-title&gt;
      &lt;img src=&quot;logo.svg&quot;&gt;
    &lt;/ion-nav-title&gt;
    &lt;ion-content&gt;
      Some super content here!
    &lt;/ion-content&gt;
  &lt;/ion-view&gt;
&lt;/ion-nav-view&gt;</pre>

<h3>nav-transition</h3>

<p>The transition type which the nav view transition should use when it animates. Current, options are <code>ios</code>, <code>android</code>, and <code>none</code>. More options coming soon.</p>

<h4>Usage</h4>
<pre>&lt;a nav-transition=&quot;none&quot; href=&quot;#/home&quot;&gt;Home&lt;/a&gt;</pre>

<h3>nav-direction</h3>

<p>The direction which the nav view transition should animate. Available options are: <code>forward</code>, <code>back</code>, <code>enter</code>, <code>exit</code>, <code>swap</code>.</p>

<h4>Usage</h4>
<pre>&lt;a nav-direction=&quot;forward&quot; href=&quot;#/home&quot;&gt;Home&lt;/a&gt;</pre>

<h3>$ionicNavBarDelegate</h3>

<p>Delegate for controlling the <code>ionNavBar</code> directive.</p>

<h4>Usage</h4>
<pre>
&lt;body ng-controller=&quot;MyCtrl&quot;&gt;
  &lt;ion-nav-bar&gt;
    &lt;button ng-click=&quot;setNavTitle(&apos;banana&apos;)&quot;&gt;
      Set title to banana!
    &lt;/button&gt;
  &lt;/ion-nav-bar&gt;
&lt;/body&gt;</pre>
<pre>function MyCtrl($scope, $ionicNavBarDelegate) {
  $scope.setNavTitle = function(title) {
    $ionicNavBarDelegate.title(title);
  }
}</pre>

<h4>Methods</h4>
<h4><code>align([direction])</code></h4>
<p>Aligns the title with the buttons in a given direction.</p>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>direction<div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>The direction to the align the title text towards. Available: 'left', 'right', 'center'. Default: 'center'.
	</p></td>
	</tr>
</tbody></table>
<h4><code>showBackButton([show])</code></h4>
<p>Set/get whether the <code>ionNavBackButton</code> is shown (if it exists and there is a previous view that can be navigated to).</p>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>show<div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>Whether to show the back button.
	</p></td>
	</tr>
</tbody></table>
<p>Returns: <code>boolean</code> Whether the back button is shown.</p>
<h4><code>showBar(show)</code></h4>
<p>Set/get whether the <code>ionNavBa</code> is shown.</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>show</td>
			<td><code>boolean</code></td>
			<td><p>Whether to show the bar.
	</p></td>
	</tr>
</tbody></table>
<p>Returns: <code>boolean</code> Whether the bar is shown.</p>
<h4><code>title(title)</code></h4>
<p>Set the title for the <code>ionNavBar</code>.</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>title</td>
			<td><code>string</code></td>
			<td><p>The new title to show.
	</p></td>
	</tr>
</tbody></table>

<h3>$ionicHistory</h3>

<p>$ionicHistory keeps track of views as the user navigates through an app. Similar to the way a browser behaves, an Ionic app is able to keep track of the previous view, the current view, and the forward view (if there is one). However, a typical web browser only keeps track of one history stack in a linear fashion.</p>

<p>Unlike a traditional browser environment, apps and webapps have parallel independent histories, such as with tabs. Should a user navigate few pages deep on one tab, and then switch to a new tab and back, the back button relates not to the previous tab, but to the previous pages visited within that tab.
</p>
<p><code>$ionicHistory</code> facilitates this parallel history architecture.</p>

<h4>Methods</h4>
<h4><code>viewHistory()</code></h4>
<p>The app’s view history data, such as all the views and histories, along with how they are ordered and linked together within the navigation stack.</p>

<p>Returns: <code>object</code> Returns an object containing the apps view history data.</p>
<h4><code>currentView()</code></h4>
<p>The app’s current view.</p>

<p>Returns: <code>object</code> Returns the current view.</p>
<h4><code>currentHistoryId()</code></h4>
<p>The ID of the history stack which is the parent container of the current view.</p>

<p>Returns: <code>string</code> Returns the current history ID.</p>
<h4><code>currentTitle([val])</code></h4>
<p>Gets and sets the current view’s title.</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>val <div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>The title to update the current view with.
	</p></td>
	</tr>
</tbody></table>
<p>Returns: <code>string</code> Returns the current view’s title.</p>
<h4><code>backView()</code></h4>
<p>Returns the view that was before the current view in the history stack. If the user navigated from View A to View B, then View A would be the back view, and View B would be the current view.</p>

<p>Returns: <code>object</code> Returns the back view.</p>
<h4><code>backTitle()</code></h4>
<p>Gets the back view’s title.</p>

<p>Returns: <code>string</code> Returns the back view’s title.</p>
<h4><code>forwardView()</code></h4>
<code>Returns the view that was in front of the current view in the history stack. A forward view would exist if the user navigated from View A to View B, then navigated back to View A. At this point then View B would be the forward view, and View A would be the current view.</code>

<p>Returns: <code>object</code> Returns the forward view.</p>
<h4><code>currentStateName()</code></h4>
<p>Returns the current state name.</p>

<p>Returns: <code>string</code></p>
<h4><code>goBack([backCount])</code></h4>
<p>Navigates the app to the back view, if a back view exists.</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>backCount <div><em>(optional)</em></div></td>
			<td><code>number</code></td>
			<td><p>Optional negative integer setting how many views to go back. By default it'll go back one view by using the value <code>-1</code>. To go back two views you would use <code>-2</code>. If the number goes farther back than the number of views in the current history's stack then it'll go to the first view in the current history's stack. If the number is zero or greater then it'll do nothing. It also does not cross history stacks, meaning it can only go as far back as the current history.
	</p></td>
	</tr>
</tbody></table>
<h4><code>removeBackView()</code></h4>
<p>Remove the previous view from the history completely, including the cached element and scope (if they exist).</p>

<h4><code>clearHistory()</code></h4>
<p>Clears out the app’s entire history, except for the current view.</p>

<h4><code>clearCache()</code></h4>
<p>Removes all cached views within every <code>ionNavView</code>. This both removes the view element from the DOM, and destroy it’s scope.</p>

<p>Returns: <code>promise</code></p>
<h4><code>nextViewOptions()</code></h4>
<p>Sets options for the next view. This method can be useful to override certain view/transition defaults right before a view transition happens. For example, the <code>menuClose</code> directive uses this method internally to ensure an animated view transition does not happen when a side menu is open, and also sets the next view as the root of its history stack. After the transition these options are set back to null.</p>

<p>Available options:</p>

<p><code>disableAnimate</code>: Do not animate the next transition.</p>
<p><code>disableBack</code>: The next view should forget its back view, and set it to null.</p>
<p><code>historyRoot</code>: The next view should become the root view in its history stack.</p>
<pre>
$ionicHistory.nextViewOptions({
  disableAnimate: true,
  disableBack: true
});</pre>

<h2>Platform</h2>
<h3>$ionicPlatform</h3>
<p>An angular abstraction of <code>ionic.Platform</code>.</p>

<p>Used to detect the current platform, as well as do things like override the Android back button in PhoneGap/Cordova.</p>

<h4>Methods</h4>
<h4><code>onHardwareBackButton(callback)</code></h4>
<p>Some platforms have a hardware back button, so this is one way to bind to it.</p>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>callback <div><em>(optional)</em></div></td>
			<td><code>function</code></td>
			<td><p>the callback to trigger when this event occurs
	</p></td>
	</tr>
	</tbody>
</table>

<h4><code>offHardwareBackButton(callback)</code></h4>
<p>Remove an event listener for the backbutton.</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>callback <div><em>(optional)</em></div></td>
			<td><code>function</code></td>
			<td><p>The listener function that was originally bound.
	</p></td>
	</tr>
	</tbody>
</table>

<h4><code>registerBackButtonAction(callback, priority, [actionId])</code></h4>
<p>Register a hardware back button action. Only one action will execute when the back button is clicked, so this method decides which of the registered back button actions has the highest priority.</p>

<p>For example, if an actionsheet is showing, the back button should close the actionsheet, but it should not also go back a page view or close a modal which may be open.</p>

<p>The priorities for the existing back button hooks are as follows: Return to previous view = 100 Close side menu = 150 Dismiss modal = 200 Close action sheet = 300 Dismiss popup = 400 Dismiss loading overlay = 500</p>

<p>Your back button action will override each of the above actions whose priority is less than the priority you provide. For example, an action assigned a priority of 101 will override the ‘return to previous view’ action, but not any of the other actions.</p>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>callback </td>
			<td><code>function</code></td>
			<td><p>Called when the back button is pressed, if this listener is the highest priority.
	</p></td>
	</tr>
	<tr>
			<td>priority </td>
			<td><code>number</code></td>
			<td><p>Only the highest priority will execute.
	</p></td>
	</tr>
	<tr>
			<td>actionld <div><em>(optional)</em></div></td>
			<td><code>*</code></td>
			<td><p>The id to assign this action. Default: a random unique id.
	</p></td>
	</tr>
	</tbody>
</table>

<p>Returns: <code>function</code> A function that, when called, will deregister this backButtonAction.</p>
<h4><code>on(type, callback)</code></h4>
<p>Add Cordova event listeners, such as <code>pause</code>, <code>resume</code>, <code>volumedownbutton</code>, <code>batterylow</code>, <code>offline</code>, etc. More information about available event types can be found in Cordova’s event documentation.</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>type </td>
			<td><code>string</code></td>
			<td><p>Cordova event type.
	</p></td>
	</tr>
	<tr>
			<td>callback </td>
			<td><code>function</code></td>
			<td><p>Called when the Cordova event is fired.
	</p></td>
	</tr>
	</tbody>
</table>


<p>Returns: function Returns a deregistration function to remove the event listener.</p>
<h4><code>ready([callback])</code></h4>
<p>Trigger a callback once the device is ready, or immediately if the device is already ready.</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>callback<div><em>(optional)</em></div> </td>
			<td><code>function=</code></td>
			<td><p>The function to call
	</p></td>
	</tr></tbody></table>

<p>Returns: <code>promise</code> A promise which is resolved when the device is ready.</p>
 <h2>Popover</h2>
<h3>$ionicPopover</h3>
<p>The Popover is a view that floats above an app’s content. Popovers provide an easy way to present or gather information from the user and are commonly used in the following situations:</p>

<p>Show more info about the current view</p>
<p>Select a commonly used tool or configuration</p>
<p>Present a list of actions to perform inside one of your views</p>
<p>Put the content of the popover inside of an <code>ion-popover-view</code> element.</p>
<h4>Usage</h4>
<pre>
&lt;p&gt;
  &lt;button ng-click=&quot;openPopover($event)&quot;&gt;Open Popover&lt;/button&gt;
&lt;/p&gt;

&lt;script id=&quot;my-popover.html&quot; type=&quot;text/ng-template&quot;&gt;
  &lt;ion-popover-view&gt;
    &lt;ion-header-bar&gt;
      &lt;h1 class=&quot;title&quot;&gt;My Popover Title&lt;/h1&gt;
    &lt;/ion-header-bar&gt;
    &lt;ion-content&gt;
      Hello!
    &lt;/ion-content&gt;
  &lt;/ion-popover-view&gt;
&lt;/script&gt;</pre>
<pre>
angular.module(&apos;testApp&apos;, [&apos;ionic&apos;])
.controller(&apos;MyController&apos;, function($scope, $ionicPopover) {

  // .fromTemplate() method
  var template = &apos;&lt;ion-popover-view&gt;&lt;ion-header-bar&gt; &lt;h1 class=&quot;title&quot;&gt;My Popover Title&lt;/h1&gt; &lt;/ion-header-bar&gt; &lt;ion-content&gt; Hello! &lt;/ion-content&gt;&lt;/ion-popover-view&gt;&apos;;

  $scope.popover = $ionicPopover.fromTemplate(template, {
    scope: $scope
  });

  // .fromTemplateUrl() method
  $ionicPopover.fromTemplateUrl(&apos;my-popover.html&apos;, {
    scope: $scope
  }).then(function(popover) {
    $scope.popover = popover;
  });


  $scope.openPopover = function($event) {
    $scope.popover.show($event);
  };
  $scope.closePopover = function() {
    $scope.popover.hide();
  };
  //Cleanup the popover when we&apos;re done with it!
  $scope.$on(&apos;$destroy&apos;, function() {
    $scope.popover.remove();
  });
  // Execute action on hide popover
  $scope.$on(&apos;popover.hidden&apos;, function() {
    // Execute action
  });
  // Execute action on remove popover
  $scope.$on(&apos;popover.removed&apos;, function() {
    // Execute action
  });
});
</pre>
<h4>Methods</h4>
<h4> <code>fromTemplate(templateString, options)</code></h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>templateString<div><em>(optional)</em></div> </td>
			<td><code>string</code></td>
			<td><p>The template string to use as the popovers's content.
	</p></td>
	</tr>
	<tr>
			<td>options<div><em>(optional)</em></div> </td>
			<td><code>object</code></td>
			<td><p>Options to be passed to the initialize method.
	</p></td>
	</tr>
	</tbody></table>


<p>Returns: <code>object</code> An instance of an <code>ionicPopover</code> controller (ionicPopover is built on top of $ionicPopover).</p>
<h4><code>fromTemplateUrl(templateUrl, options)</code></h4>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>templateUrl<div><em>(optional)</em></div> </td>
			<td><code>string</code></td>
			<td><p>The url to load the template from
	</p></td>
	</tr>
	<tr>
			<td>options<div><em>(optional)</em></div> </td>
			<td><code>object</code></td>
			<td><p>Options to be passed to the initialize method.
	</p></td>
	</tr>
	</tbody></table>

	<p>Returns: <code>promise</code> A promise that will be resolved with an instance of an <code>ionicPopover</code> controller (ionicPopover is built on top of $ionicPopover).</p>

<h3>ionicPopover</h3>

<p>Instantiated by the <code>$ionicPopover</code> service.</p>

<p>Be sure to call remove() when you are done with each popover to clean it up and avoid memory leaks.</p>

<p>Note: a popover will broadcast ‘popover.shown’, ‘popover.hidden’, and ‘popover.removed’ events from its originating scope, passing in itself as an event argument. Both the popover.removed and popover.hidden events are called when the popover is removed.</p>

<h4>Methods</h4>
<h4><code>initialize(options)</code></h4>
<p>Creates a new popover controller instance.</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>options<div><em>(optional)</em></div> </td>
			<td><code>object</code></td>
			<td><p>An options object with the following properties:</p>
			<p><code>{object=}</code> <code>scope</code> The scope to be a child of. Default: creates a child of $rootScope.</p>
			<p><code>{boolean=}</code> <code>focusFirstInput</code> Whether to autofocus the first input of the popover when shown. Default: false.</p>
			<p><code>{boolean=}</code> <code>backdropClickToClose</code> Whether to close the popover on clicking the backdrop. Default: true.</p>
			<p><code>{boolean=}</code> <code>hardwareBackButtonClose</code> Whether the popover can be closed using the hardware back button on Android and similar devices. Default: true.</p>
	</td>
	</tr>
	</tbody>
</table>

<h4><code>show($event)</code></h4>
<p>Show this popover instance.</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>$event<div><em>(optional)</em></div> </td>
			<td><code>$event</code></td>
			<td><p>The $event or target element which the popover should align itself next to.
	</p></td>
	</tr>
	</tbody></table>

<p>Returns: <code>promise</code> A promise which is resolved when the popover is finished animating in.</p>
<h4><code>hide()</code></h4>
<p>Hide this popover instance.</p>

<p>Returns: <code>promise</code> A promise which is resolved when the popover is finished animating out.</p>
<h4><code>remove()</code></h4>
<p>Remove this popover instance from the DOM and clean up.</p>

<p>Returns: <code>promise</code> A promise which is resolved when the popover is finished animating out.</p>
<h4><code>isShown()</code></h4>
<p>Returns: boolean Whether this popover is currently shown.</p>

<h2>Popup</h2>
<h3>$ionicPopup</h3>


<p>The Ionic Popup service allows programmatically creating and showing popup windows that require the user to respond in order to continue.</p>

<p>The popup system has support for more flexible versions of the built in calert()</code>, <code>prompt()</code>, and <code>confirm()</code> functions that users are used to, in addition to allowing popups with completely custom content and look.</p>

<p>An input can be given an <code>autofocus</code> attribute so it automatically receives focus when the popup first shows. However, depending on certain use-cases this can cause issues with the tap/click system, which is why Ionic prefers using the <code>autofocus</code> attribute as an opt-in feature and not the default.</p>

<h4>Usage</h4>
<p>A few basic examples, see below for details about all of the options available.</p>
<pre>
angular.module(&apos;mySuperApp&apos;, [&apos;ionic&apos;])
.controller(&apos;PopupCtrl&apos;,function($scope, $ionicPopup, $timeout) {

// Triggered on a button click, or some other target
$scope.showPopup = function() {
  $scope.data = {};

  // An elaborate, custom popup
  var myPopup = $ionicPopup.show({
    template: &apos;&lt;input type=&quot;password&quot; ng-model=&quot;data.wifi&quot;&gt;&apos;,
    title: &apos;Enter Wi-Fi Password&apos;,
    subTitle: &apos;Please use normal things&apos;,
    scope: $scope,
    buttons: [
      { text: &apos;Cancel&apos; },
      {
        text: &apos;&lt;b&gt;Save&lt;/b&gt;&apos;,
        type: &apos;button-positive&apos;,
        onTap: function(e) {
          if (!$scope.data.wifi) {
            //don&apos;t allow the user to close unless he enters wifi password
            e.preventDefault();
          } else {
            return $scope.data.wifi;
          }
        }
      }
    ]
  });

  myPopup.then(function(res) {
    console.log(&apos;Tapped!&apos;, res);
  });

  $timeout(function() {
     myPopup.close(); //close the popup after 3 seconds for some reason
  }, 3000);
 };

 // A confirm dialog
 $scope.showConfirm = function() {
   var confirmPopup = $ionicPopup.confirm({
     title: &apos;Consume Ice Cream&apos;,
     template: &apos;Are you sure you want to eat this ice cream?&apos;
   });

   confirmPopup.then(function(res) {
     if(res) {
       console.log(&apos;You are sure&apos;);
     } else {
       console.log(&apos;You are not sure&apos;);
     }
   });
 };

 // An alert dialog
 $scope.showAlert = function() {
   var alertPopup = $ionicPopup.alert({
     title: &apos;Don\&apos;t eat that!&apos;,
     template: &apos;It might taste good&apos;
   });

   alertPopup.then(function(res) {
     console.log(&apos;Thank you for not eating my delicious ice cream cone&apos;);
   });
 };
});
</pre>

<h4>Methods</h4>
<h4><code>show(options)</code></h4>
<p>Show a complex popup. This is the master show function for all popups.</p>

<p>A complex popup has a <code>buttons</code> array, with each button having a <code>text</code> and <code>type</code> field, in addition to an <code>onTap </code>function. The <code>onTap</code> function, called when the corresponding button on the popup is tapped, will by default close the popup and resolve the popup promise with its return value. If you wish to prevent the default and keep the popup open on button tap, call <code>event.preventDefault()</code> on the passed in tap event. Details below.<p>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>options<div><em>(optional)</em></div> </td>
			<td><code>object</code></td>
			<td><p>The options for the new popup, of the form:</p>
			<p><pre>
{title: &apos;&apos;, // String. The title of the popup.
  cssClass: &apos;&apos;, // String, The custom CSS class name
  subTitle: &apos;&apos;, // String (optional). The sub-title of the popup.
  template: &apos;&apos;, // String (optional). The html template to place in the popup body.
  templateUrl: &apos;&apos;, // String (optional). The URL of an html template to place in the popup   body.
  scope: null, // Scope (optional). A scope to link to the popup content.
  buttons: [{ // Array[Object] (optional). Buttons to place in the popup footer.
    text: &apos;Cancel&apos;,
    type: &apos;button-default&apos;,
    onTap: function(e) {
      // e.preventDefault() will stop the popup from closing when tapped.
      e.preventDefault();
    }
  }, {
    text: &apos;OK&apos;,
    type: &apos;button-positive&apos;,
    onTap: function(e) {
      // Returning a value will cause the promise to resolve with the given value.
      return scope.data.response;
    }
  }]
}</pre></p>
	</td>
	</tr>
	</tbody>
</table>

<p>Returns: <code>object</code> A promise which is resolved when the popup is closed. Has an additional <code>close</code> function, which can be used to programmatically close the popup.</p>
<h4><code>alert(options)</code></h4>
<p>Show a simple alert popup with a message and one button that the user can tap to close the popup.</p>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>options<div><em>(optional)</em></div> </td>
			<td><code>object</code></td>
			<td><p>The options for showing the alert, of the form:</p>
			<p><pre>
{
title: &apos;&apos;, // String. The title of the popup.
  cssClass: &apos;&apos;, // String, The custom CSS class name
  subTitle: &apos;&apos;, // String (optional). The sub-title of the popup.
  template: &apos;&apos;, // String (optional). The html template to place in the popup body.
  templateUrl: &apos;&apos;, // String (optional). The URL of an html template to place in the popup   body.
  okText: &apos;&apos;, // String (default: &apos;OK&apos;). The text of the OK button.
  okType: &apos;&apos;, // String (default: &apos;button-positive&apos;). The type of the OK button.
}
</pre></p>
	</td>
	</tr>
	</tbody>
</table>

<p>Returns: <code>object</code> A promise which is resolved when the popup is closed. Has one additional function <code>close</code>, which can be called with any value to programmatically close the popup with the given value.</p>
<h4><code>confirm(options)</code></h4>
<p>Show a simple confirm popup with a Cancel and OK button.</p>

<p>Resolves the promise with true if the user presses the OK button, and false if the user presses the Cancel button.</p>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>options<div><em>(optional)</em></div> </td>
			<td><code>object</code></td>
			<td><p>The options for showing the confirm popup, of the form:</p>
			<p><pre>
{
  title: &apos;&apos;, // String. The title of the popup.
  cssClass: &apos;&apos;, // String, The custom CSS class name
  subTitle: &apos;&apos;, // String (optional). The sub-title of the popup.
  template: &apos;&apos;, // String (optional). The html template to place in the popup body.
  templateUrl: &apos;&apos;, // String (optional). The URL of an html template to place in the popup   body.
  cancelText: &apos;&apos;, // String (default: &apos;Cancel&apos;). The text of the Cancel button.
  cancelType: &apos;&apos;, // String (default: &apos;button-default&apos;). The type of the Cancel button.
  okText: &apos;&apos;, // String (default: &apos;OK&apos;). The text of the OK button.
  okType: &apos;&apos;, // String (default: &apos;button-positive&apos;). The type of the OK button.
}
</pre></p>
	</td>
	</tr>
	</tbody>
</table>



<p>Returns: <code>object</code> A promise which is resolved when the popup is closed. Has one additional function <code>close</code>, which can be called with any value to programmatically close the popup with the given value.</p>
<h4><code>prompt(options)</code></h4>
<p>Show a simple prompt popup, which has an input, OK button, and Cancel button. Resolves the promise with the value of the input if the user presses OK, and with undefined if the user presses Cancel.</p>
<pre> 
$ionicPopup.prompt({
   title: &apos;Password Check&apos;,
   template: &apos;Enter your secret password&apos;,
   inputType: &apos;password&apos;,
   inputPlaceholder: &apos;Your password&apos;
 }).then(function(res) {
   console.log(&apos;Your password is&apos;, res);
 });</pre>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>options<div><em>(optional)</em></div> </td>
			<td><code>object</code></td>
			<td><p>The options for showing the prompt popup, of the form:</p>
			<p><pre>
{
  title: &apos;&apos;, // String. The title of the popup.
  cssClass: &apos;&apos;, // String, The custom CSS class name
  subTitle: &apos;&apos;, // String (optional). The sub-title of the popup.
  template: &apos;&apos;, // String (optional). The html template to place in the popup body.
  templateUrl: &apos;&apos;, // String (optional). The URL of an html template to place in the popup body.
  inputType: // String (default: &apos;text&apos;). The type of input to use
  defaultText: // String (default: &apos;&apos;). The initial value placed into the input.
  maxLength: // Integer (default: null). Specify a maxlength attribute for the input.
  inputPlaceholder: // String (default: &apos;&apos;). A placeholder to use for the input.
  cancelText: // String (default: &apos;Cancel&apos;. The text of the Cancel button.
  cancelType: // String (default: &apos;button-default&apos;). The type of the Cancel button.
  okText: // String (default: &apos;OK&apos;). The text of the OK button.
  okType: // String (default: &apos;button-positive&apos;). The type of the OK button.
}
</pre></p>
	</td>
	</tr>
	</tbody>
</table>
<p>Returns: <code>object</code> A promise which is resolved when the popup is closed. Has one additional function <code>close</code>, which can be called with any value to programmatically close the popup with the given value.</p>

<h2>Scroll</h2>
<h3>ion-scroll </h3>
<h4>Delegate: $ionicScrollDelegate</h4>
<p>Creates a scrollable container for all content inside.</p>

<h4>Usage</h4>
<p>Basic usage:</p>
<pre>
&lt;ion-scroll zooming=&quot;true&quot; direction=&quot;xy&quot; style=&quot;width: 500px; height: 500px&quot;&gt;
  &lt;div style=&quot;width: 5000px; height: 5000px; background: url(&apos;https://upload.wikimedia.org/wikipedia/commons/a/ad/Europe_geological_map-en.jpg&apos;) repeat&quot;&gt;&lt;/div&gt;
 &lt;/ion-scroll&gt;</pre>
 <p>Note that it’s important to set the height of the scroll box as well as the height of the inner content to enable scrolling. This makes it possible to have full control over scrollable areas.</p>

<h>If you’d just like to have a center content scrolling area, use <code>ionContent</code> instead.</h>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Attr</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>delegate-handle<div><em>(optional)</em></div> </td>
			<td><code>string</code></td>
			<td><p>The handle used to identify this scrollView with <code>$ionicScrollDelegate</code>.
	</p></td>
	</tr>
	<tr>
			<td>direction<div><em>(optional)</em></div> </td>
			<td><code>string</code></td>
			<td><p>Which way to scroll. 'x' or 'y' or 'xy'. Default 'y'.
	</p></td>
	</tr>
	<tr>
			<td>locking<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>Whether to lock scrolling in one direction at a time. Useful to set to false when zoomed in or scrolling in two directions. Default true.
	</p></td>
	</tr>
	<tr>
			<td>paging<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>Whether to scroll with paging.
	</p></td>
	</tr>
	<tr>
			<td>on-refresh<div><em>(optional)</em></div> </td>
			<td><code>expression</code></td>
			<td><p>Called on pull-to-refresh, triggered by an ionRefresher.
	</p></td>
	</tr>
	<tr>
			<td>on-scroll<div><em>(optional)</em></div> </td>
			<td><code>expression</code></td>
			<td><p>Called whenever the user scrolls.
	</p></td>
	</tr>
	<tr>
			<td>scrollbar-x<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>Whether to show the horizontal scrollbar. Default true.
	</p></td>
	</tr>
	<tr>
			<td>scrollbar-y<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>Whether to show the vertical scrollbar. Default true.
	</p></td>
	</tr>
	<tr>
			<td>zooming<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>Whether to support pinch-to-zoom
	</p></td>
	</tr>
	<tr>
			<td>min-zoom<div><em>(optional)</em></div> </td>
			<td><code>integer</code></td>
			<td><p>The smallest zoom amount allowed (default is 0.5)
	</p></td>
	</tr>
	<tr>
			<td>max-zoom<div><em>(optional)</em></div> </td>
			<td><code>integer</code></td>
			<td><p>The largest zoom amount allowed (default is 3).
	</p></td>
	</tr>
	<tr>
			<td>has-bouncing<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>Whether to allow scrolling to bounce past the edges of the content. Defaults to true on iOS, false on Android..
	</p></td>
	</tr>
	</tbody>
</table>

<h3>ion-infinite-scroll </h3>
<h4>Child of <code>ionContent</code> or <code>ionScroll</code></h4>

<p>The ionInfiniteScroll directive allows you to call a function whenever the user gets to the bottom of the page or near the bottom of the page.</p>

<p>The expression you pass in for <code>on-infinite</code> is called when the user scrolls greater than <code>distance</code> away from the bottom of the content. Once <code>on-infinite</code> is done loading new data, it should broadcast the <code>scroll.infiniteScrollComplete</code> event from your controller (see below example).</p>

<h4>Usage</h4>
<pre>
&lt;ion-content ng-controller=&quot;MyController&quot;&gt;
  &lt;ion-list&gt;
  ....
  ....
  &lt;/ion-list&gt;

  &lt;ion-infinite-scroll
    on-infinite=&quot;loadMore()&quot;
    distance=&quot;1%&quot;&gt;
  &lt;/ion-infinite-scroll&gt;
&lt;/ion-content&gt;</pre>
<pre>
function MyController($scope, $http) {
  $scope.items = [];
  $scope.loadMore = function() {
    $http.get(&apos;/more-items&apos;).success(function(items) {
      useItems(items);
      $scope.$broadcast(&apos;scroll.infiniteScrollComplete&apos;);
    });
  };

  $scope.$on(&apos;$stateChangeSuccess&apos;, function() {
    $scope.loadMore();
  });
}
</pre>
<p>An easy to way to stop infinite scroll once there is no more data to load is to use angular’s <code>ng-if</code> directive:</p>
<pre>
&lt;ion-infinite-scroll
  ng-if=&quot;moreDataCanBeLoaded()&quot;
  icon=&quot;ion-loading-c&quot;
  on-infinite=&quot;loadMoreData()&quot;&gt;
&lt;/ion-infinite-scroll&gt;
</pre>
<h4>API</h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Attr</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>on-finite<div><em>(optional)</em></div> </td>
			<td><code>expression</code></td>
			<td><p>What to call when the scroller reaches the bottom.
	</p></td>
	</tr>
	<tr>
			<td>distance<div><em>(optional)</em></div> </td>
			<td><code>string</code></td>
			<td><p>The distance from the bottom that the scroll must reach to trigger the on-infinite expression. Default: 1%.
	</p></td>
	</tr>
	<tr>
			<td>spinner<div><em>(optional)</em></div> </td>
			<td><code>string</code></td>
			<td><p>	The <code>ionSpinner</code> to show while loading. The SVG <code>ionSpinner</code> is now the default, replacing rotating font icons
	</p></td>
	</tr>
	<tr>
			<td>icon<div><em>(optional)</em></div> </td>
			<td><code>string</code></td>
			<td><p>The icon to show while loading. Default: 'ion-load-d'. This is depreicated in favor of the SVG <code>ionSpinner</code>.
	</p></td>
	</tr>
	<tr>
			<td>immediate-check<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>Whether to check the infinite scroll bounds immediately on load.
	</p></td>
	</tr>
	</tbody>
</table>

<h3>$ionicScrollDelegate</h3>

<p>Delegate for controlling scrollViews (created by ionContent and ionScroll directives).</p>

<p>Methods called directly on the $ionicScrollDelegate service will control all scroll views. Use the $getByHandle method to control specific scrollViews.</p>

<h4>Usage</h4>
<pre>
&lt;body ng-controller=&quot;MainCtrl&quot;&gt;
  &lt;ion-content&gt;
    &lt;button ng-click=&quot;scrollTop()&quot;&gt;Scroll to Top!&lt;/button&gt;
  &lt;/ion-content&gt;
&lt;/body&gt;
</pre>
<pre>
function MainCtrl($scope, $ionicScrollDelegate) {
  $scope.scrollTop = function() {
    $ionicScrollDelegate.scrollTop();
  };
}
</pre>
<p>Example of advanced usage, with two scroll areas using <code>delegate-handle</code> for fine control.</p>
<pre>
&lt;body ng-controller=&quot;MainCtrl&quot;&gt;
  &lt;ion-content delegate-handle=&quot;mainScroll&quot;&gt;
    &lt;button ng-click=&quot;scrollMainToTop()&quot;&gt;
      Scroll content to top!
    &lt;/button&gt;
    &lt;ion-scroll delegate-handle=&quot;small&quot; style=&quot;height: 100px;&quot;&gt;
      &lt;button ng-click=&quot;scrollSmallToTop()&quot;&gt;
        Scroll small area to top!
      &lt;/button&gt;
    &lt;/ion-scroll&gt;
  &lt;/ion-content&gt;
&lt;/body&gt;
</pre>
<pre> 
function MainCtrl($scope, $ionicScrollDelegate) {
  $scope.scrollMainToTop = function() {
    $ionicScrollDelegate.$getByHandle(&apos;mainScroll&apos;).scrollTop();
  };
  $scope.scrollSmallToTop = function() {
    $ionicScrollDelegate.$getByHandle(&apos;small&apos;).scrollTop();
  };
} </pre>

<h4>Methods</h4>
<h4><code>resize()</code></h4>
<p>Tell the scrollView to recalculate the size of its container.</p>

<h4><code>scrollTop([shouldAnimate])</code></h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>shouldAnimate<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>	Whether the scroll should animate.
	</p></td>
	</tr></tbody></table>
<h4><code>scrollBottom([shouldAnimate])</code></h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>shouldAnimate<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>	Whether the scroll should animate.
	</p></td>
	</tr></tbody></table>

	<h4><code>scrollTo(left, top, [shouldAnimate])</code></h4>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>left </td>
			<td><code>number</code></td>
			<td><p>	The x-value to scroll to.
	</p></td>
	</tr>
		<tr>
			<td>top </td>
			<td><code>number</code></td>
			<td><p>	The y-value to scroll to.
	</p></td>
	</tr>
	<tr>
			<td>shouldAnimate<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>	Whether the scroll should animate.
	</p></td>
	</tr>
	</tbody></table>

	<h4><code>scrollBy(left, top, [shouldAnimate])</code></h4>

	<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>left </td>
			<td><code>number</code></td>
			<td><p>	The x-offset to scroll by..
	</p></td>
	</tr>
		<tr>
			<td>top </td>
			<td><code>number</code></td>
			<td><p>	The y-offset to scroll by.
	</p></td>
	</tr>
	<tr>
			<td>shouldAnimate<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>	Whether the scroll should animate.
	</p></td>
	</tr>
	</tbody></table>

	<h4><code>zoomTo(level, [animate], [originLeft],</br> [originTop])</code></h4>

	<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>level </td>
			<td><code>number</code></td>
			<td><p>	Level to zoom to.</p></td>
		</tr>
		<tr>
			<td>animate<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>Whether to animate the zoom.</p></td>
		</tr>
		<tr>
			<td>originLeft<div><em>(optional)</em></div> </td>
			<td><code>number</code></td>
			<td><p>	Zoom in at given left coordinate.</p></td>
		</tr>
		<tr>
			<td>originTop<div><em>(optional)</em></div> </td>
			<td><code>number</code></td>
			<td><p>	Zoom in at given top coordinate.</p></td>
		</tr>
	</tbody></table>
<h4><code>zoomBy(factor, [animate], [originLeft],</br> [originTop])</code></h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>factor </td>
			<td><code>number</code></td>
			<td><p>The factor to zoom by.</p></td>
		</tr>
		<tr>
			<td>animate<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>Whether to animate the zoom.</p></td>
		</tr>
		<tr>
			<td>originLeft<div><em>(optional)</em></div> </td>
			<td><code>number</code></td>
			<td><p>	Zoom in at given left coordinate..</p></td>
		</tr>
		<tr>
			<td>originTop<div><em>(optional)</em></div> </td>
			<td><code>number</code></td>
			<td><p>Zoom in at given top coordinate.</p></td>
		</tr>
	</tbody></table>
<h4><code>getScrollPosition()</code></h4>
<p>Returns: <code>object</code> The scroll position of this view, with the following properties:</p>
<p><code>{number}</code> <code>left</code> The distance the user has scrolled from the left (starts at 0).</p>
<p><code>{number}</code> <code>top</code> The distance the user has scrolled from the top (starts at 0).</p>
<p><code>{number}</code> <code>zoom</code> The current zoom level.</p>
<h4><code>anchorScroll([shouldAnimate])</code></h4>
<p>Tell the scrollView to scroll to the element with an id matching window.location.hash.</p>

<p>If no matching element is found, it will scroll to top.</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>shouldAnimate<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>	Whether the scroll should animate.</p></td>
		</tr>
	</tbody>
</table>

<h4><code>freezeScroll([shouldFreeze])</code></h4>
<p>Does not allow this scroll view to scroll either x or y.</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>shouldFreeze<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>	Should this scroll view be prevented from scrolling or not.</p></td>
		</tr>
	</tbody>
</table>

<p>Returns: <code>boolean</code> If the scroll view is being prevented from scrolling or not.</p>
<h4><code>freezeAllScrolls([shouldFreeze])</code></h4>
<p>Does not allow any of the app’s scroll views to scroll either x or y.</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>shouldFreeze<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>Should all app scrolls be prevented from scrolling or not.</p></td>
		</tr>
	</tbody>
</table>

<h4><code>getScrollView()</code></h4>
<p>Returns: <code>object</code> The scrollView associated with this delegate.</p>
<h4><code>$getByHandle(handle)</code></h4>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>handle</td>
			<td><code>string</code></td>
			<td><p></p></td>
		</tr>
	</tbody>
</table>

<p>Returns: <code>delegateInstance</code> A delegate instance that controls only the scrollViews with delegate-handle matching the given handle.</p>
<p>Example: <code>$ionicScrollDelegate.$getByHandle</br>('my-handle').scrollTop();</code></p>

<!-- side menus -->
<h2>Side Menus</h2>
<h3>ion-side-menus</h3> 
<p>Delegate: <code>$ionicSideMenuDelegate</code></p>

<p>A container element for side menu(s) and the main content. Allows the left and/or right side menu to be toggled by dragging the main content area side to side.</p>

<p>To automatically close an opened menu, you can add the <code>menuClose</code> attribute directive. The <code>menu-close</code> attribute is usually added to links and buttons within <code>ion-side-menu-content</code>, so that when the element is clicked, the opened side menu will automatically close.</p>

<p>“Burger Icon” toggles can be added to the header with the <code>menuToggle</code> attribute directive. Clicking the toggle will open and close the side menu like the <code>menu-close</code> directive. The side menu will automatically hide on child pages, but can be overridden with the enable-menu-with-back-views attribute mentioned below.</p>

<p>By default, side menus are hidden underneath their side menu content and can be opened by swiping the content left or right or by toggling a button to show the side menu. Additionally, by adding the <code>exposeAsideWhen</code> attribute directive to an <code>ionSideMenu</code> element directive, a side menu can be given instructions about “when” the menu should be exposed (always viewable).</p>

<p>For more information on side menus, check out:</p>

<p><code>ionSideMenuContent</code></p>
<p><code>ionSideMenu</code></p>
<p><code>menuToggle</code></p>
<p><code>menuClose</code></p>
<p><code>exposeAsideWhen</code></p>

<h4>Usage</h4>
To use side menus, add an <code>&lt;ion-side-menus&gt;</code>  parent element. This will encompass all pages that have a side menu, and have at least 2 child elements: 1 <code>&lt;ion-side-menu-content&gt;</code> for the center content, and one or more <code>&lt;ion-side-menu&gt;</code> directives for each side menu(left/right) that you wish to place.
<pre>
&lt;ion-side-menus&gt;
  &lt;!-- Left menu --&gt;
  &lt;ion-side-menu side=&quot;left&quot;&gt;
  &lt;/ion-side-menu&gt;

  &lt;ion-side-menu-content&gt;
  &lt;!-- Main content, usually &lt;ion-nav-view&gt; --&gt;
  &lt;/ion-side-menu-content&gt;

  &lt;!-- Right menu --&gt;
  &lt;ion-side-menu side=&quot;right&quot;&gt;
  &lt;/ion-side-menu&gt;

&lt;/ion-side-menus&gt;
function ContentController($scope, $ionicSideMenuDelegate) {
  $scope.toggleLeft = function() {
    $ionicSideMenuDelegate.toggleLeft();
  };
}</pre>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>enable-menu-with-back-views<div><em>(optional)</em></div> </td>
			<td><code>bool</code></td>
			<td><p>Determines whether the side menu is enabled when the back button is showing. When set to <code>false</code>, any <code>menuToggle</code> will be hidden, and the user cannot swipe to open the menu. When going back to the root page of the side menu (the page without a back button visible), then any menuToggle buttons will show again, and menus will be enabled again.</p></td>
		</tr>
		<tr>
			<td>delegate-handle<div><em>(optional)</em></div> </td>
			<td><code>string</code></td>
			<td><p>The handle used to identify this side menu with <code>$ionicSideMenuDelegate</code>.</p></td>
		</tr>
	</tbody>
</table>

<h3>ion-side-menu-content</h3> 
<p>Child of <code>ionSideMenus</code></p>

<p>A container for the main visible content, sibling to one or more <code>ionSideMenu</code> directives.</p>
<h4>Usage</h4>
<pre>
&lt;ion-side-menus&gt;
  &lt;!-- Left menu --&gt;
  &lt;ion-side-menu side=&quot;left&quot;&gt;
  &lt;/ion-side-menu&gt;

  &lt;ion-side-menu-content&gt;
  &lt;!-- Main content, usually &lt;ion-nav-view&gt; --&gt;
  &lt;/ion-side-menu-content&gt;
&lt;ion-side-menu-content
  edge-drag-threshold=&quot;true&quot;
  drag-content=&quot;true&quot;&gt;
&lt;/ion-side-menu-content&gt;</pre>

<p>For a complete side menu example, see the <code>ionSideMenus</code> documentation.</p>

<h4>API</h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Attr</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>drag-content<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>	Whether the content can be dragged. Default true.</p></td>
		</tr>
		<tr>
			<td>edge-drag-threshold<div><em>(optional)</em></div> </td>
			<td><code>boolean| number</code></td>
			<td><p>Whether the content drag can only start if it is below a certain threshold distance from the edge of the screen. Default false. Accepts three types of values:</p>

<p>If a non-zero number is given, that many pixels is used as the maximum allowed distance from the edge that starts dragging the side menu.</p>
<p>If true is given, the default number of pixels (25) is used as the maximum allowed distance.</p>
<p>If false or 0 is given, the edge drag threshold is disabled, and dragging from anywhere on the content is allowed.</p></td>
		</tr>
	</tbody>
</table>

<h3>ion-side-menu</h3> 
<p>Child of <code>ionSideMenus</code></p>
<p>A container for a side menu, sibling to an <code>ionSideMenuContent</code> directive.</p>
<h4>Usage</h4>
<pre>
&lt;ion-side-menu
  side=&quot;left&quot;
  width=&quot;myWidthValue + 20&quot;
  is-enabled=&quot;shouldLeftSideMenuBeEnabled()&quot;&gt;
&lt;/ion-side-menu&gt;
</pre>
<p>For a complete side menu example, see the <code>ionSideMenus</code> documentation.</p>
<h4>API</h4>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Attr</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>side</td>
			<td><code>string</code></td>
			<td><p>Which side the side menu is currently on. Allowed values: 'left' or 'right'.</p></td>
		</tr>
		<tr>
			<td>is-enabled<div><em>(optional)</em></div> </td>
			<td><code>boolean| number</code></td>
			<td><p>Whether this side menu is enabled.</p></td>
		</tr>
		<tr>
			<td>width<div><em>(optional)</em></div> </td>
			<td><code> number</code></td>
			<td><p>How many pixels wide the side menu should be. Defaults to 275.</p></td>
		</tr>
	</tbody>
</table>

<h3>expose-aside-when</h3>
<p>Child of <code>ionSideMenus</code></p>

<p>It is common for a tablet application to hide a menu when in portrait mode, but to show the same menu on the left side when the tablet is in landscape mode. The <code>exposeAsideWhen</code> attribute directive can be used to accomplish a similar interface.</p>

<p>By default, side menus are hidden underneath its side menu content, and can be opened by either swiping the content left or right, or toggling a button to show the side menu. However, by adding the <code>exposeAsideWhen</code> attribute directive to an <code>ionSideMenu</code> element directive, a side menu can be given instructions on “when” the menu should be exposed (always viewable). For example, the <code>expose-aside-when="large"</code> attribute will keep the side menu hidden when the viewport’s width is less than <code>768px</code>, but when the viewport’s width is <code>768px</code> or greater, the menu will then always be shown and can no longer be opened or closed like it could when it was hidden for smaller viewports.</p>

<p>Using <code>large</code> as the attribute’s value is a shortcut value to <code>(min-width:768px)</code> since it is the most common use-case. However, for added flexibility, any valid media query could be added as the value, such as <code>(min-width:600px)</code> or even multiple queries such as (min-width:750px) and <code>(max-width:1200px)</code>.</p>

<h4>Usage</h4>
<pre>
&lt;ion-side-menus&gt;
  &lt;!-- Center content --&gt;
  &lt;ion-side-menu-content&gt;
  &lt;/ion-side-menu-content&gt;

  &lt;!-- Left menu --&gt;
  &lt;ion-side-menu expose-aside-when=&quot;large&quot;&gt;
  &lt;/ion-side-menu&gt;
&lt;/ion-side-menus&gt;</pre>
<p>For a complete side menu example, see the <code>ionSideMenus</code> documentation.</p>

<h3>menu-toggle</h3>

<p>Toggle a side menu on the given side.</p>

<h4>Usage</h4>
<p>Below is an example of a link within a nav bar. Tapping this button would open the given side menu, and tapping it again would close it.</p>
<pre>
&lt;ion-nav-bar&gt;
  &lt;ion-nav-buttons side=&quot;left&quot;&gt;
   &lt;!-- Toggle left side menu --&gt;
   &lt;button menu-toggle=&quot;left&quot; class=&quot;button button-icon icon ion-navicon&quot;&gt;&lt;/button&gt;
  &lt;/ion-nav-buttons&gt;
  &lt;ion-nav-buttons side=&quot;right&quot;&gt;
   &lt;!-- Toggle right side menu --&gt;
   &lt;button menu-toggle=&quot;right&quot; class=&quot;button button-icon icon ion-navicon&quot;&gt;&lt;/button&gt;
  &lt;/ion-nav-buttons&gt;
&lt;/ion-nav-bar&gt;
</pre>
<h4>Button Hidden On Child Views</h4>
<p>By default, the menu toggle button will only appear on a root level side-menu page. Navigating in to child views will hide the menu- toggle button. They can be made visible on child pages by setting the enable-menu-with-back-views attribute of the <code>ionSideMenus</code> directive to true.</p>
<pre>&lt;ion-side-menus enable-menu-with-back-views=&quot;true&quot;&gt;</pre>

<h3>menu-close</h3>

<p><code>menu-close</code> is an attribute directive that closes a currently opened side menu. Note that by default, navigation transitions will not animate between views when the menu is open. Additionally, this directive will reset the entering view’s history stack, making the new page the root of the history stack. This is done to replicate the user experience seen in most side menu implementations, which is to not show the back button at the root of the stack and show only the menu button. We recommend that you also use the <code>enable-menu-with-back-views="false"</code> <code>ionSideMenus</code> attribute when using the menuClose directive.</p>

<h4>Usage</h4>
<p>Below is an example of a link within a side menu. Tapping this link would automatically close the currently opened menu.</p>
<pre>&lt;a menu-close href=&quot;#/home&quot; class=&quot;item&quot;&gt;Home&lt;/a&gt;</pre>

<p>Note that if your destination state uses a resolve and that resolve asynchronously takes longer than a standard transition (300ms), you’ll need to set the <code>nextViewOptions</code> manually as your resolve completes.</p>
<pre>
$ionicHistory.nextViewOptions({
 historyRoot: true,
 disableAnimate: true,
 expire: 300
});</pre>

<h3>$ionicSideMenuDelegate</h3>

<p>Delegate for controlling the ionSideMenus directive.</p>

<p>Methods called directly on the $ionicSideMenuDelegate service will control all side menus. Use the $getByHandle method to control specific ionSideMenus instances.</p>

<h4>Usage</h4>
<pre>
&lt;body ng-controller=&quot;MainCtrl&quot;&gt;
  &lt;ion-side-menus&gt;
    &lt;ion-side-menu-content&gt;
      Content!
      &lt;button ng-click=&quot;toggleLeftSideMenu()&quot;&gt;
        Toggle Left Side Menu
      &lt;/button&gt;
    &lt;/ion-side-menu-content&gt;
    &lt;ion-side-menu side=&quot;left&quot;&gt;
      Left Menu!
    &lt;ion-side-menu&gt;
  &lt;/ion-side-menus&gt;
&lt;/body&gt;
</pre>
<pre>
function MainCtrl($scope, $ionicSideMenuDelegate) {
  $scope.toggleLeftSideMenu = function() {
    $ionicSideMenuDelegate.toggleLeft();
  };
}
</pre>

<h4>Methods</h4>
<h4><code>toggleLeft([isOpen])</code></h4>
<p>Toggle the left side menu (if it exists).</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>is-Open<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>Whether to open or close the menu. Default: Toggles the menu.</p></td>
		</tr>


<h4><code>toggleRight([isOpen])</code></h4>
<p>Toggle the right side menu (if it exists).</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>is-Open<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>Whether to open or close the menu. Default: Toggles the menu..</p></td>
		</tr></tbody></table>

<h4><code>getOpenRatio()</code></h4>
<p>Gets the ratio of open amount over menu width. For example, a menu of width 100 that is opened by 50 pixels is 50% opened, and would return a ratio of 0.5.</p>

<p>Returns: <code>float</code> 0 if nothing is open, between 0 and 1 if left menu is opened/opening, and between 0 and -1 if right menu is opened/opening.</p>
<h4><code>isOpen()</code></h4>
<p>Returns: <code>boolean</code> Whether either the left or right menu is currently opened.</p>
<h4><code>isOpenLeft()</code></h4>
<p>Returns: <code>boolean</code> Whether the left menu is currently opened.</p>
<h4><code>isOpenRight()</code></h4>
<p>Returns: <code>boolean</code> Whether the right menu is currently opened.</p>
<h4><code>canDragContent([canDrag])</code></h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>can-Drag<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>Set whether the content can or cannot be dragged to open side menus.</p></td>
		</tr></tbody></table>
<p>Returns: <code>boolean</code> Whether the content can be dragged to open side menus.</p>
<h4><code>edgeDragThreshold(value)</code></h4>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>value<div><em>(optional)</em></div> </td>
			<td><code>boolean|number</code></td>
			<td><p>Set whether the content drag can only start if it is below a certain threshold distance from the edge of the screen. Accepts three different values:</p>

			<p>If a non-zero number is given, that many pixels is used as the maximum allowed distance from the edge that starts dragging the side menu.</p>
			<p>If true is given, the default number of pixels (25) is used as the maximum allowed distance.</p>
			<p>If false or 0 is given, the edge drag threshold is disabled, and dragging from anywhere on the content is allowed.</p></td>
		</tr>
	</tbody>
</table>

<p>Returns: <code>boolean</code> Whether the drag can start only from within the edge of screen threshold.</p>
<h4><code>$getByHandle(handle)</code></h4>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>handle </td>
			<td><code>string</code></td>
			<td></td>
		</tr>
	</tbody>
</table>

<p>Returns: <code>delegateInstance</code> A delegate instance that controls only the <code>ionSideMenus</code> directives with <code>delegate-handle</code> matching the given handle.</p>
<p>Example: <code>$ionicSideMenuDelegate.$getByHandle</br>('my-handle').toggleLeft();</code></p>

<!-- slide box -->

<h2>Slide Box</h2>
<h3>ion-slide-box</h3> 
<p>Delegate: <code>$ionicSlideBoxDelegate</code></p>


<p>The Slide Box is a multi-page container where each page can be swiped or dragged between:</p>

<h4>Deprecated API</h4>
<p>will be removed in the next Ionic release in favor of the new ion-slides component. Don't depend on the internal behavior of this widget.</p>

<h4>Usage</h4>
<pre>
&lt;ion-slide-box on-slide-changed=&quot;slideHasChanged($index)&quot;&gt;
  &lt;ion-slide&gt;
    &lt;div class=&quot;box blue&quot;&gt;&lt;h1&gt;BLUE&lt;/h1&gt;&lt;/div&gt;
  &lt;/ion-slide&gt;
  &lt;ion-slide&gt;
    &lt;div class=&quot;box yellow&quot;&gt;&lt;h1&gt;YELLOW&lt;/h1&gt;&lt;/div&gt;
  &lt;/ion-slide&gt;
  &lt;ion-slide&gt;
    &lt;div class=&quot;box pink&quot;&gt;&lt;h1&gt;PINK&lt;/h1&gt;&lt;/div&gt;
  &lt;/ion-slide&gt;
&lt;/ion-slide-box&gt;
</pre>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Attr</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>Delegate-handle<div><em>(optional)</em></div> </td>
			<td><code>string</code></td>
			<td><p>The handle used to identify this slideBox with $ionicSlideBoxDelegate.</p></td>
		</tr>
		<tr>
			<td>does-continue<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>Whether the slide box should loop.</p></td>
		</tr>
		<tr>
			<td>auto-play<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>Whether the slide box should automatically slide. Default true if does-continue is true.</p></td>
		</tr>
		<tr>
			<td>slide-interval<div><em>(optional)</em></div> </td>
			<td><code>number</code></td>
			<td><p>How many milliseconds to wait to change slides (if does-continue is true). Defaults to 4000.</p></td>
		</tr>
		<tr>
			<td>show-pager<div><em>(optional)</em></div> </td>
			<td><code>boolean</code></td>
			<td><p>Whether a pager should be shown for this slide box. Accepts expressions via show-pager="". Defaults to true.</p></td>
		</tr>
		<tr>
			<td>pager-click<div><em>(optional)</em></div> </td>
			<td><code>expression</code></td>
			<td><p>Expression to call when a pager is clicked (if show-pager is true). Is passed the 'index' variable.</p></td>
		</tr>
		<tr>
			<td>on-slide-changed<div><em>(optional)</em></div> </td>
			<td><code>expression</code></td>
			<td><p>Expression called whenever the slide is changed. Is passed an '$index' variable.</p></td>
		</tr>
		<tr>
			<td>active-slide<div><em>(optional)</em></div> </td>
			<td><code>expression</code></td>
			<td><p>Model to bind the current slide index to.</p></td>
		</tr>
		</tbody>
	</table>

	<h3>ion-slides</h3> 
<p>Delegate: <code>$ionicSlideBoxDelegate</code></p>

<p>The Slides component is a powerful multi-page container where each page can be swiped or dragged between.</p>

<p>Note: this is a new version of the Ionic Slide Box based on the Swiper widget from idangerous.</p>
 <h4>Usage</h4>
 <pre>
 &lt;ion-content scroll=&quot;false&quot;&gt;
  &lt;ion-slides  options=&quot;options&quot; slider=&quot;data.slider&quot;&gt;
    &lt;ion-slide-page&gt;
      &lt;div class=&quot;box blue&quot;&gt;&lt;h1&gt;BLUE&lt;/h1&gt;&lt;/div&gt;
    &lt;/ion-slide-page&gt;
    &lt;ion-slide-page&gt;
      &lt;div class=&quot;box yellow&quot;&gt;&lt;h1&gt;YELLOW&lt;/h1&gt;&lt;/div&gt;
    &lt;/ion-slide-page&gt;
    &lt;ion-slide-page&gt;
      &lt;div class=&quot;box pink&quot;&gt;&lt;h1&gt;PINK&lt;/h1&gt;&lt;/div&gt;
    &lt;/ion-slide-page&gt;
  &lt;/ion-slides&gt;
&lt;/ion-content&gt;
 </pre>

 <pre>
 $scope.options = {
  loop: false,
  effect: &apos;fade&apos;,
  speed: 500,
}

$scope.$on(&quot;$ionicSlides.sliderInitialized&quot;, function(event, data){
  // data.slider is the instance of Swiper
  $scope.slider = data.slider;
});

$scope.$on(&quot;$ionicSlides.slideChangeStart&quot;, function(event, data){
  console.log(&apos;Slide change is beginning&apos;);
});

$scope.$on(&quot;$ionicSlides.slideChangeEnd&quot;, function(event, data){
  // note: the indexes are 0-based
  $scope.activeIndex = data.activeIndex;
  $scope.previousIndex = data.previousIndex;
});

 </pre>

 <h4>Slide Events</h4>
<p>The slides component dispatches events when the active slide changes</p>
<table class="jtable" style="margin:10;">
	
	<tbody>
		<tr>
			
			<td><code>$ionicSlides.slideChangeStart</code></td>
			<td><p>This event is emitted when a slide change begins</p></td>
		</tr>
		<tr>
			
			<td><code>$ionicSlides.slideChangeEnd</code></td>
			<td><p>This event is emitted when a slide change completes.</p></td>
		</tr>
		<tr>
			
			<td><code>$ionicSlides.sliderInitialized</code></td>
			<td><p>This event is emitted when the slider is initialized. It provides access to an instance of the slider.</p></td>
		</tr>
</tbody>
</table>

<h4>Updating Slides Dynamically</h4>
<p>When applying data to the slider at runtime, typically everything will work as expected.</p>

<p>In the event that the slides are looped, use the <code>updateLoop</code> method on the slider to ensure the slides update correctly.</p>
<pre>
$scope.options = {
  loop: false,
  effect: &apos;fade&apos;,
  speed: 500,
}
$scope.$on(&quot;$ionicSlides.sliderInitialized&quot;, function(event, data){
  // grab an instance of the slider
  $scope.slider = data.slider;
});

function dataChangeHandler(){
  // call this function when data changes, such as an HTTP request, etc
  if ( $scope.slider ){
    $scope.slider.updateLoop();
  }
}
</pre>
<h3>ion-slide</h3>
<p>Child of <code>ionSlideBox</code></p>

<p>Displays a slide inside of a slidebox.</p>
<h4>Usage</h4>
<pre>
&lt;ion-slide-box&gt;
  &lt;ion-slide&gt;1&lt;/ion-slide&gt;
  &lt;ion-slide&gt;2&lt;/ion-slide&gt;
&lt;/ion-slide-box&gt;
</pre>

<h3>$ionicSlideBoxDelegate</h3>

<p>Delegate that controls the <code>ionSlideBox</code> directive.</p>

<p>Methods called directly on the $ionicSlideBoxDelegate service will control all slide boxes. Use the $getByHandle method to control specific slide box instances.</p>

<h4>Usage</h4>
<pre>
&lt;ion-view&gt;
  &lt;ion-slide-box&gt;
    &lt;ion-slide&gt;
      &lt;div class=&quot;box blue&quot;&gt;
        &lt;button ng-click=&quot;nextSlide()&quot;&gt;Next slide!&lt;/button&gt;
      &lt;/div&gt;
    &lt;/ion-slide&gt;
    &lt;ion-slide&gt;
      &lt;div class=&quot;box red&quot;&gt;
        Slide 2!
      &lt;/div&gt;
    &lt;/ion-slide&gt;
  &lt;/ion-slide-box&gt;
&lt;/ion-view&gt;
</pre>
<pre>
function MyCtrl($scope, $ionicSlideBoxDelegate) {
  $scope.nextSlide = function() {
    $ionicSlideBoxDelegate.next();
  }
}
</pre>
<h4>Methods</h4>
<h4><code>update()</code></h4>
<p>Update the slidebox (for example if using Angular with ng-repeat, resize it for the elements inside).</p>

<h4><code>slide(to, [speed])</code></h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>to </td>
			<td><code>number</code></td>
			<td><p>The index to slide to.</p></td>
		</tr>
		<tr>
			<td>speed<div><em>(optional)</em></div> </td>
			<td><code>number</code></td>
			<td><p>The number of milliseconds the change should take.</p></td>
		</tr>
		</tbody>
	</table>
	<h4><code>enableSlide([shouldEnable])</code></h4>
	<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>shouldEnable <div><em>(optional)</em></div></td>
			<td><code>boolean</code></td>
			<td><p>Whether to enable sliding the slidebox.</p></td>
		</tr>
		</tbody>
	</table>
	<p>Returns: <code>boolean</code> Whether sliding is enabled.</p>
	<h4><code>previous([speed])</code></h4>
<p>Go to the previous slide. Wraps around if at the beginning.</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>speed <div><em>(optional)</em></div></td>
			<td><code>number</code></td>
			<td><p>	The number of milliseconds the change should take.</p></td>
		</tr>
		</tbody>
	</table>
	<h4><code>next([speed])</code></h4>
<p>Go to the next slide. Wraps around if at the end.</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>speed <div><em>(optional)</em></div></td>
			<td><code>number</code></td>
			<td><p>	The number of milliseconds the change should take.</p></td>
		</tr>
		</tbody>
	</table>
<h4><code>stop()</code></h4>
<p>Stop sliding. The slideBox will not move again until explicitly told to do so.</p>

<h4><code>start()</code></h4>
<p>Start sliding again if the slideBox was stopped.</p>

<h4><code>currentIndex()</code></h4>
<p>Returns: number The index of the current slide.</p>
<h4><code>slidesCount()</code></h4>
<p>Returns: number The number of slides there are currently.</p>
<h4><code>$getByHandle(handle)</code></h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>handle</td>
			<td><code>string</code></td>
			<td><p></p></td>
		</tr>
		</tbody>
	</table>
	<p>Returns: <code>delegateInstance</code> A delegate instance that controls only the <code>ionSlideBox</code> directives with <code>delegate-handle</code> matching the given handle.</p>
<p>Example: <code>$ionicSlideBoxDelegate</br>.$getByHandle('my-handle').stop();</code></p>

<!-- tabs -->
<h2>Tabs</h2>
<h3>ion-tabs</h3> 
<p>Delegate: <code>$ionicTabsDelegate</code></p>


<p>Powers a multi-tabbed interface with a Tab Bar and a set of “pages” that can be tabbed through.</p>

<p>Assign any tabs class to the element to define its look and feel.</p>

<p>For iOS, tabs will appear at the bottom of the screen. For Android, tabs will be at the top of the screen, below the nav-bar. This follows each OS’s design specification, but can be configured with the <code>$ionicConfigProvider</code>.</p>

<p>See the <code>ionTab</code> directive’s documentation for more details on individual tabs.</p>

<p>Note: do not place ion-tabs inside of an ion-content element; it has been known to cause a certain CSS bug.</p>

<h4>Usage</h4>
<pre>
&lt;ion-tabs class=&quot;tabs-positive tabs-icon-top&quot;&gt;

  &lt;ion-tab title=&quot;Home&quot; icon-on=&quot;ion-ios-filing&quot; icon-off=&quot;ion-ios-filing-outline&quot;&gt;
    &lt;!-- Tab 1 content --&gt;
  &lt;/ion-tab&gt;

  &lt;ion-tab title=&quot;About&quot; icon-on=&quot;ion-ios-clock&quot; icon-off=&quot;ion-ios-clock-outline&quot;&gt;
    &lt;!-- Tab 2 content --&gt;
  &lt;/ion-tab&gt;

  &lt;ion-tab title=&quot;Settings&quot; icon-on=&quot;ion-ios-gear&quot; icon-off=&quot;ion-ios-gear-outline&quot;&gt;
    &lt;!-- Tab 3 content --&gt;
  &lt;/ion-tab&gt;

&lt;/ion-tabs&gt;
</pre>

<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Attr</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>delegate-handle <div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>The handle used to identify these tabs with <code>$ionicTabsDelegate</code>.</p></td>
		</tr>
		</tbody>
	</table>

	<h3>ion-tab</h3> 
<p>Child of <code>ionTabs</code></p>

<p>Contains a tab’s content. The content only exists while the given tab is selected.</p>

<p>Each ionTab has its own view history.</p>

<h4>Usage</h4>
<pre>
&lt;ion-tab
  title=&quot;Tab!&quot;
  icon=&quot;my-icon&quot;
  href=&quot;#/tab/tab-link&quot;
  on-select=&quot;onTabSelected()&quot;
  on-deselect=&quot;onTabDeselected()&quot;&gt;
&lt;/ion-tab&gt;
</pre>

<p>For a complete, working tab bar example, see the ionTabs documentation.</p>

<h4><strong>API</strong></h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Attr</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>title</td>
			<td><code>string</code></td>
			<td><p>The title of the tab.</p></td>
		</tr>
		<tr>
			<td>href<div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>The link that this tab will navigate to when tapped.</p></td>
		</tr>
		<tr>
			<td>icon<div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>The icon of the tab. If given, this will become the default for icon-on and icon-off.</p></td>
		</tr>
		<tr>
			<td>icon-on <div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>The icon of the tab while it is selected.</p></td>
		</tr>
		<tr>
			<td>icon-off<div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>The icon of the tab while it is not selected.</p></td>
		</tr>
		<tr>
			<td>badge <div><em>(optional)</em></div></td>
			<td><code>expression</code></td>
			<td><p>The badge to put on this tab (usually a number).</p></td>
		</tr>
		<tr>
			<td>badge-style <div><em>(optional)</em></div></td>
			<td><code>expression</code></td>
			<td><p>The style of badge to put on this tab (eg: badge-positive).</p></td>
		</tr>
		<tr>
			<td>on-select<div><em>(optional)</em></div></td>
			<td><code>expression</code></td>
			<td><p>Called when this tab is selected.</p></td>
		</tr>
		<tr>
			<td>on-deselect<div><em>(optional)</em></div></td>
			<td><code>expression</code></td>
			<td><p>Called when this tab is deselected.</p></td>
		</tr>
		<tr>
			<td>ng-click<div><em>(optional)</em></div></td>
			<td><code>string</code></td>
			<td><p>By default, the tab will be selected on click. If ngClick is set, it will not. You can explicitly switch tabs using <code>$ionicTabsDelegate.select()</code>.</p></td>
		</tr>
		<tr>
			<td>hidden<div><em>(optional)</em></div></td>
			<td><code>expression</code></td>
			<td><p>Whether the tab is to be hidden or not.</p></td>
		</tr>
		<tr>
			<td>disabled<div><em>(optional)</em></div></td>
			<td><code>expression</code></td>
			<td><p>Whether the tab is to be disabled or not.</p></td>
		</tr>
		</tbody>
	</table>

	<h3>$ionicTabsDelegate</h3>

<p>Delegate for controlling the <code>ionTabs</code> directive.</p>

<p>Methods called directly on the $ionicTabsDelegate service will control all ionTabs directives. Use the $getByHandle method to control specific ionTabs </p>.

<h4>Usage</h4>
<pre>
&lt;body ng-controller=&quot;MyCtrl&quot;&gt;
  &lt;ion-tabs&gt;

    &lt;ion-tab title=&quot;Tab 1&quot;&gt;
      Hello tab 1!
      &lt;button ng-click=&quot;selectTabWithIndex(1)&quot;&gt;Select tab 2!&lt;/button&gt;
    &lt;/ion-tab&gt;
    &lt;ion-tab title=&quot;Tab 2&quot;&gt;Hello tab 2!&lt;/ion-tab&gt;

  &lt;/ion-tabs&gt;
&lt;/body&gt;
</pre>
<pre>
function MyCtrl($scope, $ionicTabsDelegate) {
  $scope.selectTabWithIndex = function(index) {
    $ionicTabsDelegate.select(index);
  }
}
</pre>
<h4>Methods</h4>
<h4><code>select(index)</code></h4>
<p>Select the tab matching the given index.</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>index</td>
			<td><code>number</code></td>
			<td><p>Index of the tab to select</p></td>
		</tr>
	</tbody>
</table>


<h4><code>selectedIndex()</code></h4>
<p>Returns: <code>number</code> The index of the selected tab, or -1.</p>
<h4><code>showBar(show)</code></h4>
<p>Set/get whether the <code>ionTabs</code> is shown</p>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>show</td>
			<td><code>boolean</code></td>
			<td><p>Whether to show the bar.</p></td>
		</tr>
	</tbody>
</table>


<p>Returns: <code>boolean</code> Whether the bar is shown.</p>
<h4><code>$getByHandle(handle)</code></h4>
<table class="jtable" style="margin:10;">
	<thread>
		<tr>
			<th><strong>Param</strong></th>
			<th><strong>Type</strong></th>
			<th><strong>Details</strong></th>
		</tr>
	</thread>
	<tbody>
		<tr>
			<td>handle</td>
			<td><code>string</code></td>
			<td><p></p></td>
		</tr>
	</tbody>
</table>
<p>Returns: <code>delegateInstance</code> A delegate instance that controls only the <code>ionTabs</code> directives with <code>delegate-handle</code> matching the given handle.</p>
<p>Example: <code>$ionicTabsDelegate.</br>$getByHandle('my-handle').select(0);</code></p>
<!-- tap &click -->
<h2>Tap & Click</h2>
<h3>tap</h3>

<p>On touch devices such as a phone or tablet, some browsers implement a 300ms delay between the time the user stops touching the display and the moment the browser executes the click. This delay was initially introduced so the browser can know whether the user wants to double-tap to zoom in on the webpage. Basically, the browser waits roughly 300ms to see if the user is double-tapping, or just tapping on the display once.</p>

<p>Out of the box, Ionic automatically removes the 300ms delay in order to make Ionic apps feel more “native” like. Resultingly, other solutions such as fastclick and Angular’s ngTouch should not be included, to avoid conflicts.</p>

<p>Some browsers already remove the delay with certain settings, such as the CSS property <code>touch-events</code>: none or with specific meta tag viewport values. However, each of these browsers still handle clicks differently, such as when to fire off or cancel the event (like scrolling when the target is a button, or holding a button down). For browsers that already remove the 300ms delay, consider Ionic’s tap system as a way to normalize how clicks are handled across the various devices so there’s an expected response no matter what the device, platform or version. Additionally, Ionic will prevent ghostclicks which even browsers that remove the delay still experience.</p>

<p>In some cases, third-party libraries may also be working with touch events which can interfere with the tap system. For example, mapping libraries like Google or Leaflet Maps often implement a touch detection system which conflicts with Ionic’s tap system.</p>

<h4>Disabling the tap system</h4>
<p>To disable the tap for an element and all of its children elements, add the attribute <code>codedata-tap-disabled="true"</code>.</p>
<pre>
&lt;div data-tap-disabled=&quot;true&quot;&gt;
    &lt;div id=&quot;google-map&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</pre>
<h4>Additional Notes:</h4>
<p>Ionic tap works with Ionic’s JavaScript scrolling</p>
<p>Elements can come and go from the DOM and Ionic tap doesn’t keep adding and removing listeners</p>
<p>No “tap delay” after the first “tap” (you can tap as fast as you want, they all click)</p>
<p>Minimal events listeners, only being added to document</p>
<p>Correct focus in/out on each input type (select, textearea, range) on each platform/device</p>
<p>Shows and hides virtual keyboard correctly for each platform/device</p>
<p>Works with labels surrounding inputs</p>
<p>Does not fire off a click if the user moves the pointer too far</p>
<p>Adds and removes an ‘activated’ css class</p>
<p>Multiple unit tests for each scenario</p>














































<!-- footer -->
<div class="pre-footer">
<p>The App echoes <a href="#" onlick="window.open('http://www.ionicframework.com' ','_system');">Ionic Framework's</a> documentation with a few modifications </p>

<p>Built and maintained with much love by <a href="#" onlick="window.open('http://www.twitter.com/eugeneOduma90' ','_system');"> @eugeneOduma90 </a>from Pryton Technologies</p>
<p> Doc licensed under <a href="#" onlick="window.open('http://www.apache.org/licenses/LICENCE-2.0' ','_system');">Apache 2</a> By <a href="#" onlick="window.open('http://ionicframework.com' ','_system');">Ionic Framework</a></p>
<p>Code licensed under <a href="#" onlick="window.open('http://www.opensource.org/licenses/MIT' ','_system');">MIT</a></p>
</div>

  </ion-content>
</ion-view>
